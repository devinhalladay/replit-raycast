schema {
  query: RootQueryType
  mutation: RootMutationType
  subscription: RootSubscriptionType
}

# The top level entry point for querying the graph
type RootQueryType {
  currentUser: CurrentUser

  # Finds a single user via a unique identifier
  user(id: Int!): User

  # Find a Repl by id or url
  repl(id: String, url: String): ReplQueryOutput!

  # Finds a single user via a unique identifier
  team(id: Int!): Team

  # Fetches a team organization by id
  teamOrganization(id: Int!): TeamOrganizationOutput!

  # A Board
  board(id: Int!): Board

  # A Post
  post(id: Int!): Post

  # A Comment
  comment(id: Int!): Comment

  # Finds the curent user's seen state of a tour.
  toursSeen(name: String!): ToursSeenQueryResult!

  # Finds recently edited repls
  recentRepls(
    # Number of Repls to return. Maximum of 50
    count: Int = 3

    # Whether to retrieve the user's own Repls or Repls from multiplayer sessions (including Teams Repls)
    filter: RecentReplsFilter
  ): [Repl!]!

  # Finds a board by slug
  boards(slugs: [String]): [Board!]!

  # A user's profile
  userByUsername(username: String!): User

  # A team by username
  teamByUsername(username: String!): TeamOutput!

  # Finds all reports on repls, posts, bounties, bounty applications and custom themes.
  boardReports(input: BoardReportsInputType!): BoardReports!

  # Finds a folder from its ID
  replFolderByPath(path: String!, teamName: String): ReplFolder

  # Finds the current user's notifications
  notifications(
    after: String
    count: Int
    seen: Boolean
  ): NotificationConnection!

  # Finds users whose usernames start with a given query
  usernameSearch(
    query: String!
    includeCurrentUser: Boolean
    limit: Int = 10
  ): [User!]!

  # Admin object
  admin: Admin

  # Finds trending posts with repls
  trendingReplPosts(count: Int, minVoteCount: Int): [Post!]!

  # ClUI root command
  clui: CluiQuery

  # Gets a coupon by id
  coupon(id: String!): CouponQueryOutput!

  # Returns a unique Repl title for the logged in user
  replTitle(title: String, teamId: Int): String!

  # Replit languages
  languages(search: String, limit: Int, getAll: Boolean): [Language!]!

  # Finds users based on id (with a hard max)
  usersByIds(ids: [Int!]!): [User!]!

  # Replit language
  language(id: String!): Language

  # Gets the viewer's theme
  theme: String! @deprecated(reason: "Use CurrentUser.editorPreferences.theme")

  # Returns a Custom Theme found via its ID
  customThemeById(input: CustomThemeByIdInput!): CustomThemeByIdOutput!

  # Returns an array of themes for a given search query
  themesSearch(input: ThemesSearchInput!): ThemesSearchOutput!

  # Find an annotationAnchor by id
  annotationAnchor(id: String!): AnnotationQueryOutput!

  # Find a Repl comment
  replComment(id: Int!): ReplCommentOutput!

  # Get all comments of a user
  getUserReplComments(
    input: GetUserReplCommentsInput!
  ): GetUserReplCommentsOutput

  # Returns information about connections to repls which belong to the team with the id provided
  getTeamConnections(
    # The id of the team which connections are to be fetched from
    teamId: Int!
  ): [ReplConnections!]!

  # A site-wide banner message
  siteBanner: Banner

  # The query used to fetch a template share link by its code
  teamTemplateShareLink(
    # The code of the link which we are fetching
    code: String!
  ): TeamTemplateShareLink!

  # App env value
  appEnvValue(key: String!): String

  # Finds a single tag via a unique identifier
  tag(id: String!): Tag

  # Returns existing tags in the order provided
  tags(tags: [String!]!): [Tag!]!

  # Google Classrooms associated with this user's Google account
  getGoogleClassroomCourses: GetGoogleClassroomCoursesOutput

  # Google Classroom students fetched from the API
  getGoogleClassroomStudents(
    courseId: String!
  ): GetGoogleClassroomStudentsOutput
  replTemplateById(id: Int!): ReplTemplateOutput
  languageTemplateRepls: [Repl!]!
    @deprecated(reason: "Use templateRepl2 to search for templates instead")
  betaTemplateRepls: [Repl!]!

  # Returns published curriculum for Teams
  curricula: [Curriculum!]!
  curriculumBySlug(slug: String!): CurriculumBySlugOutput!

  # Returns Repl templates and repls published as templates
  templateRepls(includeLanguages: Boolean): [TemplateReplObject!]!
    @deprecated(reason: "Use templateRepls2")

  # Returns Repl templates and Repls published as templates
  templateRepls2(options: TemplateRepls2QueryOptions!): TemplateRepls2Output!
  explainCode(
    code: String!
    language: String!
    replId: String
  ): ExplainCodeOutput!
  generateCode(input: GenerateCodeInput!): GenerateCodeOutput!
  transformCode(input: TransformCodeInput!): TransformCodeOutput!

  # Finds all posts
  replPosts(options: ReplPostsQueryOptions): PostConnection!

  # Finds all pinned posts
  pinnedPosts: [Post!]!

  # Returns tags in official and community groups
  tagGroups: TagGroups!
  previewInvoice(input: PreviewInvoiceInput!): PreviewInvoice

  # Search
  search(options: SearchQueryOptions!): SearchQueryOutput!
  threadsByFile(replId: String!, path: String!): ThreadsByFileOutput

  # Get paginated list of user events for current user.
  getUserEventsFeed(after: String, count: Int): UserEventConnection

  # Get a list of tutorial Repls, optionally filtered by category
  tutorialRepls(input: TutorialReplsInput!): TutorialReplsOutput

  # Returns the user's country code
  country: String
  instantGitHubImport(
    input: InstantGitHubImportInput!
  ): InstantGitHubImportOutput!

  # The moderator audit logs
  moderatorAuditLog(
    input: ModeratorAuditLogInputType!
  ): ModeratorAuditLogOutput!

  # Paginated image scan results
  imageScans(
    # Whether to return resolved or unresolved scans
    resolved: Boolean
    after: Int
    count: Int
    threshold: Float!
  ): ImageScansOutput

  # Find comments with spam
  searchSpamComments(
    pattern: String!
    isRegex: Boolean
    count: Int
    dateMin: DateTime
    dateMax: DateTime
    hidden: Boolean
    userId: Int
  ): [ReplComment!]!
  unverifiedEduUsers: [TeacherVerification!]!

  # Finds the Repls associated with a course's lessons
  courseLessonsRepls(
    # The course for which we want lesson Repls
    courseSlug: String!

    # The locale for which we want lesson repls. If not provided, defaults to "en-US"
    locale: String
  ): CourseLessonsReplsOutput

  # Returns a Bounty found via ID
  bountyById(input: BountyByIdInput!): BountyByIdOutput!

  # Returns a Bounty found via ID
  bountySearch(input: BountySearchInput!): BountySearchOutput!

  # Returns a set of recommended Bounties for a user, which can be displayed on the home page
  getRecommendedBountiesForUser(
    input: GetRecommendedBountiesForUserInput!
  ): GetRecommendedBountiesForUserOutput!

  # Returns a BountyApplication found via ID
  bountyApplicationById(
    input: BountyApplicationByIdInput!
  ): BountyApplicationByIdOutput!

  # Returns Bounty applications for a given Bounty
  bountyApplicationSearch(
    input: BountyApplicationSearchInput!
  ): BountyApplicationSearchOutput!

  # Returns Bounty chat messages for a given Bounty application
  bountyChatSearch(input: BountyChatSearchInput!): BountyChatSearchOutput!

  # Bounty services
  bountyHunterServiceSearch(
    input: BountyHunterServiceSearchInput!
  ): BountyHunterServiceSearchOutput!

  # Find a Bounty service by ID
  bountyHunterServiceById(
    input: BountyHunterServiceByIdInput!
  ): BountyHunterServiceByIdOutput!

  # Returns a Bounty found via its URL, the username and slug
  bountyByUrl(input: BountyByUrlInput!): BountyByUrlOutput!

  # Returns existing template categories.
  templateCategories(input: TemplateCategoriesInput): TemplateCategoriesOutput

  # Return a template category via its slug
  templateCategoryBySlug(
    input: TemplateCategoryBySlugInput!
  ): TemplateCategoryBySlugOutput!

  # Replit Support Asset Upload
  supportAssetUpload(filename: String!): SupportAssetUrls!
  extensionList(includeNonBlessed: Boolean = false, userId: Int): [Extension!]!

  # Return a template repl via its landing page slug
  templateReplBySlug(input: TemplateReplBySlugInput!): TemplateReplBySlugOutput!

  # Return list of all templates that have landing pages
  templateLandingPages: [TemplateReview!]!

  # Get a community-banned user by their ID
  getBannedBoardUser(userId: Int!): GetBannedBoardUserOutput
  studentsSubmissions(
    input: StudentsSubmissionsInput!
  ): StudentsSubmissionsOutput

  # Returns the boot status history for a given repl
  replBootStatusHistory(
    input: ReplBootStatusHistoryInput!
  ): ReplBootStatusHistoryOutput!

  # Returns all recently active repl boot status for current users repls
  replBootStatus(input: ReplBootStatusInput): ReplBootStatusOutput!

  # Creates a URL for embedding the Tipalti Payee iFrame
  tipaltiIframeUrl: TipaltiIframeUrl!

  # Returns the Neon databases for a given user or repl
  getNeonDatabases(input: GetNeonDatabasesInput!): GetNeonDatabasesOutput!

  # Users who tipped the most on Replit
  topGlobalTippers(
    # The number of users to return. Max 25.
    limit: Int!
  ): TopGlobalTippersOutput!

  # Returns the available Goval continents
  replContinents: ReplContinents!

  # Get Repls that a user has permitted to use Repl Identity to authenticate as them
  allowedReplIdentityRepls: AllowedReplIdentityRepls!

  # Load an invoice by ID.
  invoiceById(
    # The ID of the invoice.
    id: String!
  ): InvoiceOutput!
  extension(id: String!): ExtensionOutput

  # Returns all extension installations for the user (and optionally scoped to a repl)
  extensionInstallationById(id: String!): ExtensionInstallationByIdOutput!

  # Returns all extension installations available to the current user in the provided repl
  extensionInstallations(replId: String!): ExtensionInstallationsOutput!

  # Preview a change to a users subscription, to see what the proration would be
  previewProration(input: PreviewProrationInput!): PreviewProrationOutput!

  # Total value value in cycles of all available bounties from a given user; if not specified, returns the total value of all available bounties.
  totalBountiesCyclesValue(userId: Int): Int!

  # Returns a list of subscription plans supported
  subscriptionPlans: SubscriptionPlansOutput!

  # Returns hosting deploy build action history.
  hostingBuildDeployActionHistory(
    input: HostingBuildDeployActionHistoryInput!
  ): HostingBuildDeployActionHistoryOutput!

  # Returns whether or not a given title is available for a repl
  availableReplTitle(input: AvailableReplTitleInput!): AvailableReplTitleOutput!

  # Returns a Replit Checkout Session
  getReplitCheckoutSession(
    input: GetReplitCheckoutSessionInput!
  ): GetReplitCheckoutSessionOutput!

  # Returns whether a replit.app subdomain is available for use.
  replitAppSubdomainAvailability(
    # The subdomain for which to check availability
    subdomain: String!

    # An optional deploymentId, used to validate a subdomain for an existing deployment
    deploymentId: String
  ): ReplitAppSubdomainAvailabilityOutput!

  # Resolve an anonymous feature flag
  anonymousFlag(input: AnonymousFlagInput!): AnonymousFlagOutput!
}

# Authenticated user
type CurrentUser {
  id: Int!
  email: String!
  username: String!
  firstName: String
  lastName: String
  locale: String!
  emailNotifications: Boolean!
  isVerified: Boolean
  timeCreated: DateTime!
  timeUpdated: DateTime!
  displayName: String!
  fullName: String!
  url: String!
  bio: String
  location: String
  socials: [UserSocial!]!
  hasRepl: Boolean!
  hasRole(role: UserRoles!): Boolean!
  hasPrivacyRole: Boolean!
  roles(only: [UserRoles!]): [UserRole!]!
  isLoggedIn: Boolean!
  isSubscribed: Boolean!

  # Finds the user's warnings
  warnings: [Warning]
  followers(after: String, count: Int): UserConnection!
  followerCount: Int!
  follows(after: String, count: Int): UserConnection!
  followCount: Int!

  # Determines whether a user is banned from talk/canny
  isBannedFromBoards: Boolean!

  # If banned, this is the reason why they were banned.
  bannedFromBoardsReason: String

  # Determines whether a user has a hacker plan
  isHacker: Boolean!
    @deprecated(
      reason: "Use `subscriptionIsType` or `userSubscriptionType` instead"
    )

  # Checks if the user has an active subscription of the given type
  subscriptionIsType(
    # User level subscription types
    subscriptionType: UserSubscriptionTypeEnum!
  ): Boolean!

  # Returns the type of plan, if the user has a plan from the Hacker family of plans.
  userSubscriptionType: UserSubscriptionTypeEnum
  gate(feature: String!): Boolean!
  allGates: [UserGate!]!
    @deprecated(reason: "No longer supported. Use currentUser.allFlags instead")
  allFlags: [Flag!]!
  flag(controlName: String!, type: UserFlagValueType): Flag!
  gateVariation(feature: String!): String
  tourSeen(name: String!): Boolean!
  toursSeen(tours: [String!]!): [TourSeen!]!
  cannySSOToken: String!
  canUpdate(column: UserUpdateColumns!): Boolean!

  #
  replSearch(
    search: String!

    # Only include repls owned by the user.
    excludeMultiplayer: Boolean = true

    # Only include public repls.
    excludePrivate: Boolean = false
    count: Int
  ): [Repl!]!
  paginatedReplSearch(
    search: String!

    # Only include repls owned by the user.
    excludeMultiplayer: Boolean = true

    # Only include public repls.
    excludePrivate: Boolean = false
    count: Int
    after: String
  ): ReplConnection!
  state: UserState

  # A list of languages the current user has coded in, and optionally the languages they have selected as interested in
  languages(includeInterestedIn: Boolean, limit: Int): [Language!]!
  sidebarClosed: Boolean!
  search: UserSearchResults!
  hasProfileImage: Boolean!
  image: String!

  # User profile cover image
  coverImage: CoverImage
  socialSignup: Boolean!
  auth(provider: UserAuthProviders!): UserAuth
  repositories(
    count: Int!
    after: String
    privacy: RepositoryPrivacy
  ): RepositoriesOutput

  # GitHub specific information for a GitHub authed user
  gitHubInfo: GitHubInfo

  # A Repl with slug matching the user's username
  usernameRepl: Repl
  daysSinceSignup: Int!
  clui: JSON!

  # User's editor preferences
  editorPreferences: EditorPreferences!

  # Finds a folder based on id
  replFolder(id: String!, teamId: Int): ReplFolder

  # Finds a folder based on path
  replFolderByPath(path: String!): ReplFolder

  # How many teams is the user part of
  teamsCount: Int!

  # List of teams the user is a member of
  teams: [Team!]!

  # List of teams without a subscription
  freeTeams: [Team!]!
  teamOrganizations(
    # Select a type of org by subscription type
    subscriptionType: TeamOrganizationSubscriptionTypeEnum
  ): [TeamOrganization!]!

  # Teams that are connected to a Google Classroom
  googleClassroomTeams: [Team!]!

  # Returns true if a user has boost remaining, false otherwise
  canBoost: Boolean!

  # Finds the current user's notification count
  notificationCount: Int!

  # The current user's billing info
  billingInfo: BillingInfo

  # The current user's customer entity
  customer: Customer

  # If a user qualifies for onboarding
  hasOnboarding: Boolean! @deprecated(reason: "This experiment is done")

  # If a user qualifies for apps onboarding
  hasAppsOnboarding: Boolean! @deprecated(reason: "This experiment is done")

  # If a user should see a privacy update
  hasPrivacyUpdate: Boolean!

  # Whether the user has authorized Replit to access their Google Classroom data
  hasGoogleClassroomScope: Boolean!

  # A list of groups of template repls or langauges
  createReplOptions: [CreateReplOptionGroup!]!

  # A list of the users favorite template repls or langauges
  favoriteCreateReplOptions: [CreateReplOptions!]!

  # Whether the user has access to generate code, explain code, and transform code.
  hasContextualAIFeatures: Boolean!
    @deprecated(
      reason: "Support for contextual AI features alone is a legacy feature. Use currentUser.powerUpsByType.ghostwriter.active instead"
    )
  canCreateNewFreeTeam: Boolean!

  # Subscription capabilities for the user
  capabilities: SubscriptionCapabilities

  # Determines whether to show the user's presence on the site
  showPresence: Boolean!

  # Determines wether user has completed edu verification form
  showVerifyTeacherBanner: Boolean!

  # Determines wether user is currently in firewall mode or not
  isFirewallMode: Boolean!

  # Cycles state for the user
  cycles: Cycles!

  # The Goval continent of the user
  replContinent: ReplContinent!

  # Searches repls a user can publish
  publishableReplSearch(search: String!, count: Int): [Repl!]!

  # The User's active custom theme
  activeThemeVersion: ThemeVersion

  # Returns the current user's installed custom themes
  installedThemes(
    input: CurrentUserInstalledThemesInput!
  ): CurrentUserInstalledThemesOutput!

  # Returns the themes authored by the current user
  authoredThemes(
    input: CurrentUserAuthoredThemesInput!
  ): CurrentUserAuthoredThemesOutput!

  # Repl Power Ups summary
  replPowerUps: [ReplPowerUpDescriptionType!]!

  # User Power Ups summary
  userPowerUps: [UserPowerUpDescriptionType!]!
    @deprecated(reason: "Use userPowerUpsByType instead")

  # State of user-scoped Power Ups, by key
  userPowerUpsByType: UserPowerUpsTypesOutput!
  powerUpCosts: UserPowerUpCost!
    @deprecated(reason: "Use userPowerUpsByType instead")
  pricesUpdate: CurrentUserPricesUpdateOptionOutput!
    @deprecated(reason: "2022 Repricing is over")

  # Fetches a course by slug for the authed user.
  course(slug: String!): UserCourseOutput!

  # Fetches courses for the authed user.
  courses: [UserCourse!]!

  # Fetches the lesson details for the authed user, given a repl ID, if any.
  replLesson(replId: String!): UserCourseLessonOutput

  # Whether or not the user is allowed to be a Bounty solver
  canBeBountySolver: Boolean!
    @deprecated(
      reason: "No longer needed to gate access to applying - anyone can apply"
    )

  # All active Repl Power Ups for the current user
  replPowerUpsByMethodOfPayment(
    methodOfPayment: PowerUpMethodOfPayment
  ): CurrentUserReplPowerUpsByMethodOfPaymentOutput!

  # Returns information about the current user's egress consumption.
  egress: CurrentUserEgressOutput!

  # Storage information for the user
  storageInfo: StorageInfo!
  paymentMethod: UserPaymentMethod
  cyclesAutoRefillConfiguration: UserCyclesAutoRefillConfigurationOutput

  # A fast, approximate count of how many "Recent Repls" entries the user has, used to render directionally correct loading states.
  recentReplsCount(
    # Whether to retrieve the user's own Repls or Repls from multiplayer sessions (including Teams Repls)
    filter: RecentReplsFilter
  ): Int!
  signupMethod: String
  keybindings(
    environment: KeybindingsEnvironmentEnum!
    platform: KeybindingsPlatformEnum!
  ): Keybindings!
  isImpersonated: Boolean!
}

# A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
scalar DateTime

# Social media profile links associated with a user profile
type UserSocial {
  id: Int!
  url: String!
  type: user_socialstypeEnumType!
}

enum user_socialstypeEnumType {
  twitter
  facebook
  linkedin
  github
  discord
  youtube
  twitch
  website
}

enum UserRoles {
  SELF_LEARNER
  TEACHER
  STUDENT
  ADMIN
  MODERATOR
  EXPLORER
  DETECTIVE
  TESTER
  DEVELOPER
  LANGUAGE_JAMMER
  PRIVACY_LIMITED_ACCESS
  GITHUB_CLASSROOM_USER
  TEMPLATE_DEVELOPER
  BUSINESS
  ONBOARDING_EXPERIENCE_NONE
  ONBOARDING_EXPERIENCE_LOW
  ONBOARDING_EXPERIENCE_MEDIUM
  ONBOARDING_EXPERIENCE_HIGH
  INTENT_PERSONAL
  INTENT_STUDENT
  INTENT_TEACHER
  INTENT_BUSINESS
  TEACHER_UNVERIFIED
  TEACHER_REJECTED
  REPLIT_STAFF
  FEATURED
  REPLIT_REP
  REPLIT_IDENTITY_TESTING
  DAYS_OF_CODE
  REPLIT_REP_EDU
  PATRON
  PYTHONISTA
  VERIFIED_BOUNTY_HUNTER
}

# A role belonging to a user
type UserRole {
  id: String!
  key: UserRoles!
  name: String!
  tagline: String
}

# A warning received by the user from Repl Talk moderators.
type Warning {
  id: Int!
  reason: String!

  # The user who received the warning.
  user: User

  # The moderator who issued the warning.
  moderator: User
  timeCreated: DateTime!
}

# A user of Replit
type User {
  id: Int!
  username: String!
  firstName: String
  lastName: String
  locale: String!
  isVerified: Boolean
  displayName: String!
  fullName: String!
  url: String!
  bio: String
  location: String
  socials: [UserSocial!]!
  hasRole(role: UserRoles!): Boolean!
  hasPrivacyRole: Boolean!
  roles(only: [UserRoles!]): [UserRole!]!
  isFollowedByCurrentUser: Boolean!
  isFollowingCurrentUser: Boolean!
  isBlockedByCurrentUser: Boolean!
  isBlockingCurrentUser: Boolean!
  isLoggedIn: Boolean!
  isSubscribed: Boolean!
  timeCreated: DateTime!

  # Finds the public repls for a user
  publicRepls(
    pinnedReplsFirst: Boolean
    showUnnamed: Boolean
    before: String
    after: String
    count: Int
    order: String
    direction: String
  ): ReplConnection!
  followers(after: String, count: Int): UserConnection!
  followerCount: Int!
  follows(after: String, count: Int): UserConnection!
  followCount: Int!

  # Repls pinned on the profile
  pinnedRepls: [Repl!]!

  # Repls searched on the profile
  profileRepls(
    search: String
    before: String
    after: String
    count: Int
    order: String
    direction: String
  ): ReplConnection!

  # Finds the user's warnings
  warnings: [Warning]

  # Finds the user's posts
  posts(
    after: String
    count: Int
    order: String
    unlisted: Boolean
  ): PostConnection

  # Determines whether a user is banned from talk/canny
  isBannedFromBoards: Boolean!

  # Determines whether a user has a hacker plan
  isHacker: Boolean!
    @deprecated(
      reason: "Use `subscriptionIsType` or `userSubscriptionType` instead."
    )

  # Checks if the user has an active subscription of the given type
  subscriptionIsType(
    # User level subscription types
    subscriptionType: UserSubscriptionTypeEnum!
  ): Boolean!

  # Returns the type of plan, if the user has a plan from the Hacker family of plans.
  userSubscriptionType: UserSubscriptionTypeEnum

  # A list of langauges the user has coded in
  languages(limit: Int): [Language!]!

  # Whether a user has a gated feature
  gate(feature: String!): Boolean!
  image: String!

  # User profile cover image
  coverImage: CoverImage
  teamPermissions(teamId: Int!): TeamPermission
  redirectToTeamDashboard: Boolean!

  # Gives datetime for last time this user was seenon the site and whether they should be considered online now
  presenceStatus: UserPresenceStatus!

  # Stats about a user's activity in Bounties
  bountyStats: BountyUserStats!

  # Information about a user's activity in Bounties
  bountyInfo: BountyInfo!
}

# A connection to a list of Repls.
type ReplConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of Repls.
  items: [Repl!]!
}

# Information about pagination in a connection.
type PageInfo {
  # Next results available
  hasNextPage: Boolean!

  # Previous results available
  hasPreviousPage: Boolean!

  # Cursor to fetch next page
  nextCursor: String

  # Cursor to fetch previous page
  previousCursor: String
}

# A repl
type Repl {
  id: String!
  isPrivate: Boolean!
  isStarred: Boolean!
  title: String!
  slug: String!
  imageUrl: String
  folderId: String
  isRenamed: Boolean

  # The comment count for a repl
  commentCount: Int!

  # The like count for a repl
  likeCount: Int!

  # If the current has liked this repl
  currentUserDidLike: Boolean!

  # A list of groups of repls
  relatedRepls(limitPerGroup: Int): [RelatedReplsGroup!]!

  # The category of the template if the Repl is one
  templateCategory: String
    @deprecated(reason: "Deprecated in favour of repl.templateCategories field")
  languageExamples(asText: Boolean): [LanguageExample!]
    @deprecated(reason: "User legacyLanguageConfig.examples")
  deprecatedLanguageConfig(asText: Boolean): Language!

  # Whether or not this Repl was posted to Talk/Community
  wasPosted: Boolean!

  # Whether or not this Repl was published to Apps
  wasPublished: Boolean!

  # The Repl's layout for the current user
  layoutState: JSON
  language: String!
  user: User
  origin: Repl
  lang: Language!

  # The icon url for a repl
  iconUrl: String!

  # The template label for a repl
  templateLabel(disableFallbackToTitle: Boolean): String!
  url(lite: Boolean): String!
  inviteUrl: String
  multiplayerInvites: [MultiplayerInvite!]!
  analyticsUrl: String
  rootOriginReplUrl: String
  timeCreated: DateTime!
  timeUpdated: DateTime!
  isOwner(canWrite: Boolean): Boolean!
  config: ReplConfig!
  pinnedToProfile: Boolean!

  # Sum of size (in bytes) of all files in this repl
  size: Float!
    @deprecated(reason: "Repl size is no longer available in the GraphQL API")
  hostedUrl(dotty: Boolean, protocol: Protocols, dev: Boolean): String!
  terminalUrl: String!
    @deprecated(reason: "Terminal hosting no longer supported")
  nextPagePathname: String!

  # Can the requester edit the repl title, description, and public status, also if can they delete it and move it between folders
  currentUserPermissions: ReplUpdatePermissions!
  database: Database
  checkDomain2(domain: String!): CheckDomain2
  permissions: [ReplPermission!]! @deprecated(reason: "Use multiplayers field")
  template: ReplTemplate
  betaTemplateRepl: Repl
  isProject: Boolean!
  isProjectFork: Boolean!
  isModelSolution: Boolean!
  isModelSolutionFork: Boolean!
  workspaceCta: ReplWorkspaceCta!
  submission: ReplSubmission
  annotationAnchors: [AnnotationAnchor!]!
  owner: ReplOwner
  unitTests: ReplUnitTestsWithMeta
  unitTestResults: [ReplUnitTestResultsOutput!]
  ioTests: [ReplTemplateTest!]!
  recentForks(count: Int): [Repl!]!
  posts(after: String, count: Int): PostConnection!
  comments(after: String, count: Int): ReplCommentConnection!
  commentSettings: ReplCommentSetting

  # Count of public forks of this repl
  publicForkCount: Int!

  # Number of times this repl has been run
  runCount: Int!

  # Public forks of this repl
  publicForks(after: String, count: Int, search: String): ReplConnection!
  isAlwaysOn: Boolean!
  isBoosted: Boolean!

  # The storage capacity of the Repl
  storageCapacity: StorageCapacityOutputType!
    @deprecated(
      reason: "This field is part of an experimental feature and will change in the future.It should not be depended upon."
    )

  # A Repl's used storage
  bytesUsed: ReplBytesUsedOutput!

  # Does this repl have a GPU enabled?
  hasGpu: Boolean!

  # What is the guaranteed provisioning SKU of this repl?
  guaranteedProvisioningSku: SKU!
    @deprecated(reason: "Use repl.powerUps.boost.sku instead")

  # Deployment for this repl
  deployment: ReplDeployment

  # Releases of this repl
  releases(after: String, count: Int): ReplReleaseConnection!
  gateOnOwner(feature: String!): Boolean!

  # Tags on this repl
  tags: [Tag!]!

  # Examples of a repl
  examples: [Repl!]!

  # Results for when IO tests where executed most recently on the repl, only for edu repls.
  ioTestResults: [IOTestResult!]

  # Multiplayers of this Repl
  multiplayers: [User!]!

  # The language this nix template Repl is replacing
  nixedLanguage: String

  # Returns how this repl was published or null if unpublished
  publishedAs: PublishedReplKind

  # Files stored in the db that are associated with this Repl (non-container files)
  attachments(
    # Optional attachment filename to fetch
    fileName: String
  ): [ReplAttachment!]!

  # Return's a repl's source
  source: ReplSource

  # Returns apps derived from this Repl if it's a template
  derivedApps(after: String, count: Int): ReplConnection

  # The count of ALL repls forked from one of this repl's releases (currently misnamed, not public only)
  publicReleasesForkCount: Int!
    @deprecated(reason: "Use releasesForkCount instead")

  # The count of all repls forked from all of this repl's releases
  releasesForkCount: Int!

  # Return's a repl's description
  description(
    # removes Markdown formatting from text
    plainText: Boolean
  ): String

  # Information about a Repl's template. For Repls that don't have a template, returns information about the canonical language Repl
  templateInfo: ReplTemplateInfo!
  recentComments: [ReplComment!]!

  # All domains associated with this repl.
  domains: [Domain]

  # Address for the apex domain proxy for apex domain linking.
  apexProxy: String!
  replViewSettings: ReplViewSettings
  powerUpCosts: PowerUpCostsOutput!

  # State of repl-scoped Power Ups, by key
  powerUps: ReplPowerUpTypesOutput!

  # The template label for a repl
  templateReview: TemplateReview

  # The template categories for a template repl
  templateCategories: [TemplateCategory]!
  isTutorial: Boolean!

  # The Repl owner's course lesson state
  lesson: UserCourseLesson

  # Total tips received by this repl, inclusive of fees (if any), in cycles
  totalCyclesTips: Int!

  # Users who have tipped this Repl the most
  topTippers: [TipperUser!]!

  # Total tips received by this repl from a given user (by ID), inclusive of fees (if any), in cycles. Null if user is not logged in.
  currentUserTotalTips: Int

  # When the repl was last published
  lastPublishedAt: DateTime
  hostingDeployment: ReplHostingDeployment

  # Returns the last 1000 log lines for a hosting deployment Repl
  hostingDeploymentLogs(
    # Hosting deployment ID for which we want logs
    deploymentId: String!
  ): ReplLogsOutput!
  hostingDeploymentPermissions: ReplHostingDeploymentPermissions!

  # The top n Repl analytics field values for a given time period
  analyticsTopList(input: ReplAnalyticsTopInput): ReplAnalyticsTopListOutput!

  # The top n Repl analytics field values for a given time period
  analyticsPageViews(
    input: ReplAnalyticsPageViewsInput
  ): ReplAnalyticsPageViewsOutput!

  # Repl metric values, broken out by hour, inside of a given time period.
  analyticsTimeSeries(
    input: ReplAnalyticsTimeSeriesInput
  ): ReplAnalyticsTimeSeriesOutput!
}

# A group of related repls
type RelatedReplsGroup {
  # The name of the group
  name: String!

  # A list of repls
  repls: [Repl!]!
}

# Example code for a language
type LanguageExample {
  mainFile: String!
  name: String!
  code: String!
}

# A Repl language
type Language {
  id: String!
  supportsMultiFiles: Boolean!
    @deprecated(reason: "all languages support multi files now")
  usesInterpreter: Boolean!
  canUseShellRunner: Boolean!
  usesTerminal2: Boolean! @deprecated(reason: "all languages use terminal2 now")
  hasUPM: Boolean!
  hasLibSearch: Boolean!
  supportsPackager3: Boolean!
  supportsGit: Boolean!
  displayName: String!
  key: String!
  category: String!
  tagline: String!
  icon: String
  engine: String
  isNew: Boolean
  isDeprecated: Boolean!
    @deprecated(
      reason: "We're migrating languages on the fly, never deprecating them"
    )
  mainFile: String!
  examples: [LanguageExample!]
  header: String
  tagName: String!
  aliases: [LanguageAlias!]
  hasReplboxWebview: Boolean!
  hasReplboxUrlBar: Boolean!
  nixTemplateRepl: Repl
  templateRepl: Repl
  betaTemplateRepl: Repl
  recentReplsCreatedCount: Int!
  hasDAP: Boolean!
  hasGit: Boolean!
}

# Example code for a language
type LanguageAlias {
  displayName: String!
  tagline: String!
  icon: String!
  category: String!
}

# The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
scalar JSON

# An emailed invite to join Replit multiplayer
type MultiplayerInvite {
  email: String!
  replId: String!
  type: multiplayer_invitestypeEnumType!
  repl: Repl
}

enum multiplayer_invitestypeEnumType {
  r
  rw
}

type ReplConfig {
  isServer: Boolean
  gitRemoteUrl: String
  domain: String @deprecated(reason: "Superseded by repl.domains")
  isVnc: Boolean
  alwaysOn: Boolean @deprecated(reason: "Superseded by repl.isAlwaysOn")
  doClone: Boolean
}

# Web protocols
enum Protocols {
  HTTPS
  WSS
}

# Allowed actions to be taken by the requesting user
type ReplUpdatePermissions {
  changeTitle: Boolean!
  changeDescription: Boolean!
  changeImageUrl: Boolean!
  changeIconUrl: Boolean!
  changeTemplateLabel: Boolean!
  changeLanguage: Boolean!
  changeConfig: Boolean!
  changePrivacy: ReplChangePrivacyPermission!
  star: Boolean!
  pin: Boolean!
  move: Boolean!
  delete: Boolean!
  leaveMultiplayer: Boolean!
  editMultiplayers: Boolean!
  viewHistory: Boolean!
  containerAttach: Boolean!
  containerWrite: Boolean!
  changeAlwaysOn: ReplChangeAlwaysOnPermission!
  linkDomain: Boolean!
  writeTests: Boolean!
  changeCommentSettings: Boolean!
  inviteGuests: Boolean!
  publish: Boolean!
  fork: Boolean!
}

enum ReplChangePrivacyPermission {
  Allowed
  Disallowed
  SubscriptionRequired
    @deprecated(
      reason: "We no longer use permissions as a proxy for subscription status"
    )
}

enum ReplChangeAlwaysOnPermission {
  Allowed
  Disallowed
  SubscriptionRequired
    @deprecated(
      reason: "We no longer use permissions as a proxy for subscription status"
    )
}

# A repl-specific key-value database
type Database {
  id: ID!
  jwt: String!
    @deprecated(
      reason: "Clients should no longer use a JWT to talk directly to kv.repl.it. Use sibling fields on Database instead."
    )
  keysCount: Int
  sizeMB: Float
}

union CheckDomain2 = NotFoundError | ServiceUnavailable | DomainStatus2

# An error caused by being unable to locate a resource
type NotFoundError {
  message: String!
}

# An error caused by a service being unavailable
type ServiceUnavailable {
  message: String!
}

# Checks if CNAME is correctly configued for a given domain to be linked.
type DomainStatus2 {
  status: String
  retry: Boolean!
  verified: Boolean!
  records: DomainStatusRecords
}

# DNS records that were obtained as part of a domain link check.
type DomainStatusRecords {
  A: [String!]
  CNAME: [String!]
  TXT: [String!]
}

# Access permissions for a repl
type ReplPermission {
  id: Int!
  userId: Int!
  replId: String!
  type: repl_permissionstypeEnumType!
  timeCreated: DateTime!
  timeUpdated: DateTime!
  repl: Repl
  user: User
}

enum repl_permissionstypeEnumType {
  r
  rw
}

# A template for repls
type ReplTemplate {
  id: Int!
  imageUrl: String
  hoverImageUrl: String
  order: Int
  dueDate: Date
  availableStartDate: Date
  availableEndDate: Date
  isPublished: Boolean!
  isGroupProject: Boolean!
  restrictAfterSubmit: Boolean!
  allowSelfGrouping: Boolean!
  selfGroupSize: Int
  repl: Repl!
  modelSolution: ReplTemplateModelSolution
  author: User!
  tests: [ReplTemplateTest!]!
  team: Team
  url: String!

  # Returns all project submission groups. Only applies to group projects.
  submissionGroups: [ReplSubmissionGroup!]!
  submissionInfo: ReplTemplateSubmissionInfo

  # Returns the submissions the user has permission to access.
  submissions: [ReplSubmission!]!
  userSubmissionGroup: ReplSubmissionGroup
}

# A special custom Scalar type for Dates that converts to a ISO formatted string
scalar Date

# A model submission for a Repl template
type ReplTemplateModelSolution {
  id: Int!
  visibleAfterSubmitting: Boolean!
  visibleAfterDueDate: Boolean!
  visibleAfterPassingTests: Boolean!

  # Repl containing the solution files
  repl: Repl!

  # Can the current user fork the model solution. Determined by the rules of the model solution
  canStudentFork: Boolean!

  # Student fork of the model solution. Student only view the model solution via a fork.
  studentFork: Repl
}

# A test for a template repl
type ReplTemplateTest {
  id: Int!
  name: String!
  input: String!
  output: String!
  timeCreated: Date!
  type: ReplTemplateTestType!
  template: ReplTemplate!
}

enum ReplTemplateTestType {
  match
  exact
  regex
  compatibility
}

# A team inside Replit
type Team {
  id: Int!
  username: String!

  # Whether this Team has been archived
  archived: Boolean

  # Description of the team
  description: String!

  # Display name for the team
  displayName: String!

  # List of members of the team
  memberCount: Int!

  # A list of pending invites
  openInvites: [TeamInvite]!

  # Google Classroom connected to this Team
  googleClassroom: GoogleClassroom

  # List of members of the team, only visible to users in the team
  members(
    permissions: String

    # Optionally limit the number of members queried and returned.
    limit: Int
  ): [TeamMembership!]!

  # Organization that owns this team (only for paid teams)
  organization: TeamOrganization

  # Profile image for the team
  image: String!

  # Whether the user is a member of the team or not
  isMember: Boolean!

  # Whether the current user is an admin in the team or not
  isAdmin: Boolean!

  # Whether the current user is the team owner or not.
  isOwner: Boolean!

  # Whether the current user has permission to manage the team's billing or not
  hasBillingPerms: Boolean!
  inviteLink: TeamInviteLink
  recentRepls(count: Int!): [Repl!]!

  # Determines if this team has privacy invites
  hasPrivacyInvites: Boolean!

  # Determines if this team has invite link with edu_signup property
  hasEduSignupInvites: Boolean!

  # Determines if this team is eligible for team templates
  hasTemplates: Boolean!

  # Visible team templates based on the requesting user's role
  templates(published: Boolean): [ReplTemplate!]!

  # Checks subscription type
  subscriptionIsType(
    # Select a type of org by subscription type
    subscriptionType: TeamSubscriptionTypeEnum
  ): Boolean!

  # Gates applying to the team as opposed to the user
  gate(
    feature: String!

    # Select a type of org by subscription type
    subscriptionType: TeamSubscriptionTypeEnum
  ): Boolean!

  # Returns true if this team has not been migrated to use stacks for its templates
  needsMigrationToStacks: Boolean!

  # Returns a stack of template repls that do not belong to any stack
  defaultTemplateStack: Stack!

  # Returns a stack of repls that do not belong to any stack
  defaultReplStack: Stack!

  # Stacks belonging to the team
  stacks: [Stack!]!

  # Collections of templates
  collections(
    # Optional size for templates.
    batchSize: Int
  ): [TeamCollection!]!

  # The template share links for the team
  templateShareLinks: [TeamTemplateShareLink!]!

  # Records of templates being shared
  templateShares: [TeamTemplateShare!]!
  url: String!

  # List of guests of the team
  guests: [TeamGuest!]!

  # Curricula that has been impored into this team
  curriculumImports: [Curriculum!]!

  # Subscription capabilities for the organization this team belongs to
  capabilities: SubscriptionCapabilities
  userPermissions: TeamUserPermissions
  followerCount: Int!
  isFollowedByCurrentUser: Boolean!
}

# An invite to a team
type TeamInvite {
  id: Int!
  externalId: String

  # The team the invite belongs to
  team: Team!

  # Whether the invitation has been accepted or not
  accepted: Boolean!

  # The username for the user the invite belongs to (or their email)
  usernameOrEmail: String

  # The icon for the user the invite belongs to
  image: String!
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# Google Classroom entry point
type GoogleClassroom {
  id: Int!
  name: String!
  courseId: String!

  # Google Classroom students invites to Replit
  members: [GoogleClassroomMember]!
}

type GoogleClassroomMember {
  id: Int!
  externalId: String!
  user: User
  invite: TeamInvite
}

# A member of a team
type TeamMembership {
  id: Int!
  nickname: String
  user: User

  # The member's permissions for the team
  permissions: TeamPermission!

  # Team member email; only visible to team admin
  email: String
}

# The permissions a user has for a team
enum TeamPermission {
  admin
  member
  billing_admin
  owner
}

# Owns and manages teams
type TeamOrganization {
  id: Int!
  name: String!
  isVerified: Boolean!
  customer: Customer
  subscription: TeamOrganizationSubscription

  # Whether the pending verification badge is visible or not
  showVerificationBadge: Boolean!

  # Determines if the user owns the organizaiton
  isOwner: Boolean

  # Determines if the user is an admin on the organization
  isAdmin: Boolean!

  # List of members of the org
  members: [TeamOrganizationMembership!]!
  teams: [Team!]!

  # Count of active teams belonging to this org
  teamsCount: Int
  archivedTeams: [Team!]!

  # Count of archived teams belonging to this org
  archivedTeamsCount: Int
  unsubscribedTeams: [Team!]!
  unsubscribedTeamsCount: Int

  # Subscription capabilities for the organization
  capabilities: SubscriptionCapabilities
  userPermissions: TeamOrganizationUserPermissions
  pendingInvites: [TeamOrganizationInvite!]!
  inviteLink: TeamOrganizationInviteLink
  canBeDeleted: Boolean!
  quantity: Int
}

# Customer billing information; all subscriptions are parented to this entity.
type Customer {
  id: Int!
  stripeCustomerId: String
  paymentMethod: customerspaymentMethodEnumType
  timeUpdated: Date
  timeCreated: Date!
  timeDeleted: Date
}

enum customerspaymentMethodEnumType {
  card
  check
  bank
}

# Team organization subscription information
type TeamOrganizationSubscription {
  id: Int!
  stripeStatus: team_organization_subscriptionsstripeStatusEnumType
  planId: String!
  origin: String!
  isTrial: Boolean!
  months: Int
  quantity: Int
  quickbooksInvoiceId: String
  timeExpired: Date
  timeUpdated: Date
  timeCreated: Date!
  timeDeleted: Date
  isEducationPlan: Boolean!
  isBusinessPlan: Boolean!
  isPerSeatPlan: Boolean!
  canAddEducationTeam: Boolean!
  isFlatPlan: Boolean!
  isExpiring(daysFromNow: Int!): Boolean!
  teamOrganization: TeamOrganization
  canCreateNewTeam: Boolean!
}

enum team_organization_subscriptionsstripeStatusEnumType {
  active
  past_due
  unpaid
  canceled
  incomplete
  incomplete_expired
  trialing
}

# A member of an org
type TeamOrganizationMembership {
  id: Int!
  role: team_organization_membersroleEnumType
  user: User
}

enum team_organization_membersroleEnumType {
  team
  owner
  admin
}

# Capabilities for subscriptions and users on subscriptions
type SubscriptionCapabilities {
  isEducationPlan: Boolean!
  isBusinessPlan: Boolean!
  isPerSeatPlan: Boolean!
  canAddEducationTeam: Boolean!

  # Whether or not the current user can create an edu trial
  canCreateEduTrial: Boolean!
  isFlatPlan: Boolean!
  isExpiring(daysFromNow: Int!): Boolean!
  canCreateNewTeam: Boolean!
  canCreatePrivateRepl: Boolean!
  canViewOwnPrivateRepl: Boolean!
  availableSeats: Int!
  hasValidSubscription: Boolean!
  memberCount: Int!
  associatedUserIds: [Int]!
  canBoost: Boolean!
  isTrial: Boolean!
}

# Organization permissions that the current user has
type TeamOrganizationUserPermissions {
  canViewOrgSettings: Boolean!
  canEditBilling: Boolean!
  canCancelPlan: Boolean!
  canDeleteOrg: Boolean!
  canLeaveOrg: Boolean!
  canAddOrgOwners: Boolean!
  canAddOrgAdmins: Boolean!
  canRemoveOrgAdmins: Boolean!
  canRemoveOrgOwners: Boolean!
  canCreateTeamsInOrg: Boolean!
  canViewTitlesOfAllTeams: Boolean!
  canViewContentsOfAllTeams: Boolean!
}

# An invite to a team organization
type TeamOrganizationInvite {
  id: Int!

  # The organization the invite belongs to
  organization: TeamOrganization!

  # Whether the invitation has been accepted or not
  accepted: Boolean!

  # The username for the user the invite belongs to (or their email)
  usernameOrEmail: String

  # The invited user
  user: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# An invite link for a team organization
type TeamOrganizationInviteLink {
  id: Int!
  code: String!
}

# An invite link for a team
type TeamInviteLink {
  id: Int!
  code: String!
  eduSignup: Boolean!
}

enum TeamSubscriptionTypeEnum {
  EDUCATION
  PRO
}

# List of ordered repls
type Stack {
  id: Int!
  title: String!
  description: String

  # Number of repls in the stack
  replsCount: Int!

  # ReplTemplates that belong to the stack
  replTemplates: [ReplTemplate!]!

  # Repls that belong to the stack
  repls: [Repl!]!
}

# Collection of team templates
type TeamCollection {
  # Title of the collection. Can be null if unnamed
  title: String

  # Does the collection contain any group projects
  hasGroupProject: Boolean!

  # Templates loaded from the collection
  templates: [ReplTemplate]!
}

# A link which can be used to copy templates from one team to another.
type TeamTemplateShareLink {
  id: Int!
  code: String!

  # The templates which should be copied when the link is used
  templates: [ReplTemplate!]!

  # The default stack which holds standalone templates to be copied.This value will be null if the team template share link does not contain any standalone templates
  defaultStack: LinkStack

  # The stacks which should be copied when the link is used
  stacks: [LinkStack!]!
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# A stack to copied when a share link is used
type LinkStack {
  # The id of the stack to be copied
  id: Int!

  # The title of the stack to be copied
  title: String

  # A list of ids of the templates within the stack to be copied
  templates: [Int!]!
}

# An instance where a body of templates were copied from one team to another.
type TeamTemplateShare {
  id: Int!

  # The team which the templates that were copied were copied from
  from: Team!

  # The team which the templates copied were copied to
  to: Team!

  # The templates which were copied
  templates: [ReplTemplate!]!
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# A guest of a team
type TeamGuest {
  id: Int!
  user: User
}

# Education content created for Teams
type Curriculum {
  id: Int!
  slug: String!
  title: String!
  description: String!
  coverPhotoUrl: String
  isFeatured: Boolean

  # Languages used in curriculum projects
  languages: [Language]!

  # Stacks containing the lessons as repls in. Returns the latest curriculum version; otherwise, provide a specific curriculum version.
  contents(
    # Optional version number for fetching a specific curriculum version
    versionNumber: Int
  ): CurriculumContentOutput!
}

union CurriculumContentOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | CurriculumContent

# An error caused by a user's request being bad / invalid
type UserError {
  message: String!
}

# An error caused by a user attempting to access a resource without authorization
type UnauthorizedError {
  message: String!
}

type CurriculumContent {
  versionNumber: Int!
  units: [Stack!]!
}

# Team permissions that the current user has
type TeamUserPermissions {
  canArchiveTeam: Boolean!
  canDeleteTeam: Boolean!
  canRenameTeam: Boolean!
  canLeaveTeam: Boolean!
  canAddTeamOwners: Boolean!
  canAddTeamAdmins: Boolean!
  canRemoveTeamAdmins: Boolean!
  canAddTeamMembers: Boolean!
  canRemoveTeamMembers: Boolean!
  canAddGuests: Boolean!
  canRemoveGuests: Boolean!
  canCreateTeamRepls: Boolean!
  canEditTeamRepls: Boolean!
  canDeleteTeamRepls: Boolean!
  canSubmitProjects: Boolean!
}

# A submission for template repls
type ReplSubmissionGroup {
  submission: ReplSubmission
  users: [User]!
}

# A submission for template repls
type ReplSubmission {
  id: Int!
  timeSubmitted: Date
  timeLastReviewed: Date
  isGroupSubmission: Boolean!
  repl: Repl
  author: User
  submissionGroup: ReplSubmissionGroup
}

type ReplTemplateSubmissionInfo {
  submittedCount: Int!
  startedCount: Int!
}

enum ReplWorkspaceCta {
  Share
  ShareUpgrade
  CreateTemplate
  PublishTemplate
  EditTemplate
  Submit
  Resubmit
  UpdateModelSolution
  ReviewSubmission
  Auth
}

# A single Annotation Anchor
type AnnotationAnchor {
  id: String!
  path: String
  otVersion: Int
  indexStart: Int
  indexEnd: Int
  timeCreated: DateTime!
  timeUpdated: DateTime!

  # Whether the annotation is resolved
  isResolved: Boolean!

  # The messages attached to the Annotation Anchor
  messages: [AnnotationMessage!]!

  # The users participating in the thread
  participants: [User!]!
  repl: Repl
  user: User

  # The number of messages in the thread
  messageCount: Int!
  unreadCount: Int!
  currentUserIsAuthor: Boolean!
  isGeneral: Boolean!
}

# A single Annotation Message
type AnnotationMessage {
  id: String!
  timeCreated: DateTime!
  timeUpdated: DateTime!
  text: String! @deprecated(reason: "Superseded by content")
  content: MessageContentType!
  anchor: AnnotationAnchor
  user: User
  seen: Boolean
  currentUserIsAuthor: Boolean!
}

union MessageContentType =
    TextMessageContentType
  | StatusMessageContentType
  | PreviewMessageContentType

# A thread message containing text, usually from a user
type TextMessageContentType {
  text: String!
}

# A thread message indicating a status change.
type StatusMessageContentType {
  status: String!
}

# A thread message previewing a message. It may or may not have text.
type PreviewMessageContentType {
  preview: String
}

union ReplOwner = Team | User

# a suite of unit tests with included metadata
type ReplUnitTestsWithMeta {
  tests: [ReplUnitTest!]!
  meta: ReplUnitTestMeta
}

# A unit test for a Repl Repl
type ReplUnitTest {
  id: Int!
  name: String!
  code: String
  failureMessage: String
  repl: Repl!
  lastRun(replId: String!): ReplUnitTestLastRunOutput
}

union ReplUnitTestLastRunOutput = ReplUnitTestLastRun | UserError

type ReplUnitTestLastRun {
  status: ReplUnitTestLastRunStatus
}

enum ReplUnitTestLastRunStatus {
  PASSED
  FAILED
  NONE
}

# Metadata for a Repl unit test
type ReplUnitTestMeta {
  id: Int!
  imports: String
  initialization: String
  setup: String
  tearDown: String
}

type ReplUnitTestResultsOutput {
  id: Int!
  status: ReplUnitTestLastRunStatus
}

# A connection to a list of Posts.
type PostConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of Posts.
  items: [Post!]!
}

# A board to post repls to
type Post {
  id: Int!
  title: String
  showHosted: Boolean
  voteCount: Int!
  commentCount: Int!
  isPinned: Boolean
  isHidden: Boolean!
  isLocked: Boolean
  timeCreated: DateTime!
  timeUpdated: DateTime!
  body: String!
  url: String!
  user: User
  board: Board
  repl: Repl
  replComment: ReplComment
  comments(after: String, count: Int, order: String): CommentConnection

  # Finds a post's votes
  votes(
    before: String
    after: String
    count: Int
    order: String
    direction: String
  ): PostVoteConnection
  isAnnouncement: Boolean!
  isAuthor: Boolean!
  canEdit: Boolean!
  canComment: Boolean!
  canVote: Boolean!
  canPin: Boolean!
  canHide: Boolean!
  canSetType: Boolean!
  canChangeBoard: Boolean!
  canLock: Boolean!
  hasVoted: Boolean!
  canReport: Boolean!
  hasReported: Boolean!
  isAnswered: Boolean!
  isAnswerable: Boolean!
  answeredBy: User
  answer: Comment
  preview(length: Int, removeMarkdown: Boolean): String!
  recentComments(count: Int): [Comment!]
  recentReplComments: [ReplComment!]
}

# A board to post repls to
type Board {
  id: Int!
  name: String!
  description: String
  slug: String!
  cta: String
  titleCta: String
  bodyCta: String
  template: String
  buttonCta: String
  color: String
  replRequired: Boolean!
  isLocked: Boolean!
  isAnswerable: Boolean!
  isPrivate: Boolean!
  timeCreated: DateTime!
  timeUpdated: DateTime!
  url: String!
  canPost: Boolean!
}

# A comment on a post or another comment
type ReplComment {
  id: Int!
  timeCreated: DateTime!
  timeUpdated: DateTime!
  body(removeMarkdown: Boolean): String!
  user: User
  isHidden: Boolean
  repl: Repl
  parentComment: ReplComment
  post: Post
  replies: [ReplComment!]!
  canEdit: Boolean! @deprecated(reason: "Use currentUserPermissions.edit")
  canComment: Boolean!
  currentUserPermissions: ReplCommentPermissions
}

# Allowed actions to be taken by the user viewing a comment
type ReplCommentPermissions {
  id: Int!
  edit: Boolean!
  delete: Boolean!
  banAuthor: Boolean!
  canHideComment: Boolean!
  report: Boolean!
}

# A connection to a list of Comments.
type CommentConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of Comments.
  items: [Comment!]!
}

# A comment on a post or another comment
type Comment {
  id: Int!
  body: String!
  voteCount: Int!
  timeCreated: DateTime!
  timeUpdated: DateTime!
  user: User
  url: String!
  post: Post
  repl: Repl
  parentComment: Comment
  comments: [Comment]
  isAuthor: Boolean!
  canEdit: Boolean!
  canVote: Boolean!
  canComment: Boolean!
  hasVoted: Boolean!
  canReport: Boolean!
  hasReported: Boolean!
  isAnswer: Boolean!
  canSelectAsAnswer: Boolean!
  canUnselectAsAnswer: Boolean!
  preview(length: Int, removeMarkdown: Boolean): String!
}

# A connection to a list of PostVotes.
type PostVoteConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of PostVotes.
  items: [PostVote!]!
}

# A board to post repls to
type PostVote {
  id: Int!
  user: User
  post: Post
}

# A connection to a list of ReplComments.
type ReplCommentConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of ReplComments.
  items: [ReplComment!]!
}

# comment related settings for a repl
type ReplCommentSetting {
  id: Int!
  enabled: Boolean!
}

union StorageCapacityOutputType = UnauthorizedError | StorageCapacity

type StorageCapacity {
  # The value of the storage capacity of the Repl
  value: ReplStorageCapacity!
}

enum ReplStorageCapacity {
  Standard
  TwoGigs
  FourGigs
  EightGigs
  SixteenGigs
  ThirtyTwoGigs
  SixtyFourGigs
}

union ReplBytesUsedOutput =
    ServiceUnavailable
  | NotFoundError
  | UnauthorizedError
  | ReplBytesUsed

# A Repl's used storage
type ReplBytesUsed {
  # Total bytes of storage used by the Repl. Represented as a string because GiB can easily exceed int32.
  value: String!
}

enum SKU {
  standard
  boosted_1
  boosted_2
  boosted_3
  boosted_4
}

# A repl deployment
type ReplDeployment {
  id: Int!
  domain: String
  timeCreated: DateTime!
  timeUpdated: DateTime!
  repl: Repl
  activeRelease: ReplRelease
}

# A Repl release
type ReplRelease {
  id: String!
  description: String!
  pending: Boolean!
  timeCreated: DateTime!
  timeUpdated: DateTime!
  repl: Repl
  user: User

  # Returns a summary of changes between the repl's current files and this release's files.
  pendingChanges: [ReplFileChange!]!
  hostedUrl: String!
}

type ReplFileChange {
  fileName: String!
  changeType: ReplFileChangeType!
}

enum ReplFileChangeType {
  NewFile
  ModfiedFile
  DeletedFile
}

# A connection to a list of ReplReleases.
type ReplReleaseConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of ReplReleases.
  items: [ReplRelease!]!
}

# A tag
type Tag {
  id: String!
  isOfficial: Boolean!
}

# The result of an IO test being run on a repl
type IOTestResult {
  # The output of the program when the test was executed.
  output: String!

  # The status of the test that was executed.
  status: IOTestResultStatus!

  # A unique ID for the result type
  id: ID!

  # The test which was executed to get the result
  test: IOTestResultTestType!

  # The repl which the test the result belongs to was executed on for this result.
  repl: IOTestResultReplType!
}

# The status of a result of an IO test.
enum IOTestResultStatus {
  # The IO tests passed.
  passed

  # The IO tests failed.
  failed
}

union IOTestResultTestType = NotFoundError | ReplTemplateTest

union IOTestResultReplType = NotFoundError | Repl

enum PublishedReplKind {
  RegularRepl
  Template
  App
}

type ReplAttachment {
  id: Int!
  fileName: String!
  mimeType: String!
  timeCreated: Date!
  timeUpdated: Date

  # File contents
  contents: String!
}

# A source points to a specific release of a repl
type ReplSource {
  release: ReplRelease
  deployment: ReplDeployment
}

# The template info for a repl
type ReplTemplateInfo {
  replId: String
  label: String!
  iconUrl: String!
}

# A domain linked to a repl.
type Domain {
  domain: String!
  state: String!
  hosting_deployment_id: String
}

# settings related to viewing a Repl outside of the workspace
type ReplViewSettings {
  id: Int!
  defaultView: repl_view_settingsdefaultViewEnumType!
  replFile: String
  repl: Repl!
  replImage: String
}

enum repl_view_settingsdefaultViewEnumType {
  repl_file
  repl_image
}

union PowerUpCostsOutput = UnauthorizedError | NotFoundError | PowerUpCostsType

# The cost associated with various Power Ups for a given Repl
type PowerUpCostsType {
  boost: PowerUpCostDetailType!
  alwaysOn: PowerUpCostDetailType!
  gpu: PowerUpCostDetailType!
  boost2cpu2ram: PowerUpCostDetail2Type!
  boost4cpu4ram: PowerUpCostDetail2Type!
  boost8cpu8ram: PowerUpCostDetail2Type!
  boost16cpu16ram: PowerUpCostDetail2Type!
  hostingTierE2Micro: PowerUpCostDetail2Type
  hostingTierE2Small: PowerUpCostDetail2Type
  hostingTierE2Medium: PowerUpCostDetail2Type
  hostingTierN1Custom1_4: PowerUpCostDetail2Type
  hostingTierE2Standard2: PowerUpCostDetail2Type
  hostingTierE2Standard4: PowerUpCostDetail2Type
}

# The cost associated with a given Power Up
type PowerUpCostDetailType {
  cycles: Int!
  explanation: PowerUpCostExplanationEnumType!
}

# The explanation for how a cost was set
enum PowerUpCostExplanationEnumType {
  # Requires the user to buy more cycles
  NEEDS_CYCLES

  # Requires the user to get a subscription (i.e. Hacker or Teams Pro)
  NEEDS_SUBSCRIPTION

  # Included in the user's subscription (i.e. Hacker or Teams Pro)
  INCLUDED_IN_SUBSCRIPTION

  # Included in a user or Repl's existing order
  INCLUDED_IN_EXISTING_ORDER

  # Requires the user to spend cycles
  SPEND_CYCLES

  # Requires activation an existing order
  ACTIVATE_EXISTING_ORDER

  # This product is not supported for team
  NOT_SUPPORTED_FOR_TEAMS

  # Activating the power up will trigger Cycles auto-refill
  AUTO_REFILL
}

# The cost associated with a given Power Up
type PowerUpCostDetail2Type {
  cyclesCostNow: Int!
  cyclesCostRecurring: Int!
  methodOfPayment: PowerUpCostMethodOfPaymentEnum!
  explanation: PowerUpCostExplanationEnumType!
}

enum PowerUpCostMethodOfPaymentEnum {
  SUBSCRIPTION
  CYCLES
  INVALID
}

union ReplPowerUpTypesOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | ReplPowerUpTypes

# State of user-scoped Power Ups
type ReplPowerUpTypes {
  boost: BoostPowerUpType!
  hostingTier: HostingTierPowerUpType
}

# State of the Boost Power Up
type BoostPowerUpType {
  # Resources (vCPU, RAM) provided by the Power Up
  sku: BoostSKUEnum!

  # If active, the explanation for how the Power Up was created
  methodOfPayment: PowerUpMethodOfPayment
}

enum BoostSKUEnum {
  off
  boost_2cpu_2ram
  boost_4cpu_4ram
  boost_8cpu_8ram
  boost_16cpu_16ram
}

enum PowerUpMethodOfPayment {
  SUBSCRIPTION
  CYCLES
}

# State of the Hosting Tier Power Up
type HostingTierPowerUpType {
  # Hosting tier machine type (vCPU, RAM) provided by the Power Up
  sku: HostingTierPowerUpSku!

  # If active, the explanation for how the Power Up was created
  methodOfPayment: PowerUpMethodOfPayment!
}

enum HostingTierPowerUpSku {
  hosting_tier_e2_micro
  hosting_tier_e2_small
  hosting_tier_e2_medium
  hosting_tier_n1_custom_1_4
  hosting_tier_e2_standard_2
  hosting_tier_e2_standard_4
}

# Review status of a Template
type TemplateReview {
  id: Int!
  promoted: Boolean!
  landingPageSlug: String
  timeCreated: Date!
  timeUpdated: Date
  timeDeleted: Date
  repl: Repl
  release: ReplRelease
  deployment: ReplDeployment
  reviewedBy: User
}

# A template category.
type TemplateCategory {
  id: Int!
  title: String!
  description: String
  slug: String!
  imageUrl: String
  order: Int
  timeCreated: Date!
}

# A course lesson started by a user.
type UserCourseLesson {
  id: Int!
  lessonSlug: String!
  timeCompleted: Date
  timeCreated: Date!

  # The course under which the lesson belongs.
  course: UserCourse!

  # The forked Repl belonging to this lesson. Nullable in case the Repl is deleted.
  repl: Repl
}

# A course started by a user.
type UserCourse {
  id: Int!
  courseSlug: String!
  timeCreated: Date!

  # The course lessons the user has started.
  lessons: [UserCourseLesson!]
}

# A user who made a tip
type TipperUser {
  # The user who tipped. Can be null if such user was deleted, or got banned.
  user: User

  # The amount of tips the user has given
  totalCyclesTipped: Int!
}

union ReplHostingDeployment =
    NotFoundError
  | UnauthorizedError
  | UserError
  | HostingDeployment

# A hosting deployment for a repl, only accessible by users with write access to target Repl
type HostingDeployment {
  id: String!
  replitAppSubdomain: String
  timeCreated: Date!
  timeUpdated: Date

  # The canonical repl for this deployment
  repl: Repl!

  # The latest build attached to this deployment, for initial deployments this could be in "building" or "failed" or "success" status
  currentBuild: HostingBuild!

  # If a deployment has an actively deploying hosting build
  inProgressBuild: HostingBuild

  # The activity logs for this deployment, for initial deployments an activity log can be of type "rollback" or "deploy"
  activityLogs(
    before: String
    after: String
    count: Int
    order: String
    direction: String
  ): HostingActivityLogConnection!
}

# A hosting build to be used in a hosting deployment, only accessible by users with write access to target Repl
type HostingBuild {
  id: String!
  description: String!
  timeCreated: Date!
  timeUpdated: Date

  # The status of this hosting build
  status: HostingBuildStatus!

  # The status of this hosting build
  provider: HostingBuildProvider!

  # The canonical repl for this deployment
  repl: Repl!

  # The user who created this build
  user: User!

  # Does the hosting build have an image tag assigned to it
  hasImageTag: Boolean!

  # The hosting builds environment variables
  envVars: [HostingBuild2EnvVar!]!
}

enum HostingBuildStatus {
  pending
  building
  running
  promoting
  failed
  success
  updating_tier
  suspending
  suspended
  resuming
}

enum HostingBuildProvider {
  goval
  gce
  cloud_run
  static
}

type HostingBuild2EnvVar {
  name: String!
  value: String!
}

# A connection to a list of HostingActivityLogs.
type HostingActivityLogConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of HostingActivityLogs.
  items: [HostingActivityLog!]!
}

# Logs of activity for a hosting deployment, only accessible by users with write access to target Repl
type HostingActivityLog {
  id: Int!
  timeCreated: Date!

  # The type of activity log
  type: HostingActivityLogType!

  # The hosting deployment associated with this activity log
  deployment: HostingDeployment!

  # The hosting build associated with this activity log
  build: HostingBuild!

  # The user who initiated the action
  user: User!
}

enum HostingActivityLogType {
  deploy
  rollback
  fail
}

union ReplLogsOutput = ReplLogs

type ReplLogs {
  result: [ReplLog!]!
}

type ReplLog {
  timestamp: DateTime!
  line: String!
}

type ReplHostingDeploymentPermissions {
  canDeploy: Boolean!
}

union ReplAnalyticsTopListOutput =
    NotFoundError
  | UserError
  | ReplAnalyticsTopList

# A list of top Repl analytics results
type ReplAnalyticsTopList {
  results: [ReplAnalyticsTopResult!]!
}

# A metric name and value pair
type ReplAnalyticsTopResult {
  value: String!
  count: Int!
}

input ReplAnalyticsTopInput {
  # Analytics field for which we want the top results
  metric: String!

  # Localized start for the window where the want the metrics
  start: DateTime!

  # Number of consecutive hours for which we want results. Max 168.
  hours: Int!

  # Return results for the associated deployment Repl. Defaults to false.
  deployment: Boolean

  # Number of top items to return. Defaults to 10, max 100.
  count: Int
}

union ReplAnalyticsPageViewsOutput =
    NotFoundError
  | UserError
  | ReplAnalyticsPageViews

# A summary of a Repl's page views
type ReplAnalyticsPageViews {
  # The number of unique users across the reporting period.
  uniques: Int!

  # Hourly page views for the Repl
  results: [ReplAnalyticsPageViewsData!]!
}

# An hourly timestamp and the number of page views during that period.
type ReplAnalyticsPageViewsData {
  timestamp: DateTime!
  success: Int!
  failure: Int!
}

input ReplAnalyticsPageViewsInput {
  # Localized start for the window where the want the page view data.
  start: DateTime!

  # Number of consecutive hours for which we want results. Max 168.
  hours: Int!

  # Return results for the associated deployment Repl. Defaults to false.
  deployment: Boolean
}

union ReplAnalyticsTimeSeriesOutput =
    NotFoundError
  | UserError
  | ReplAnalyticsTimeSeries

# Time series data for a metric across a given period.
type ReplAnalyticsTimeSeries {
  # Hourly metric data for the Repl
  results: [ReplAnalyticsTimeSeriesData!]!
}

# An hourly timestamp, the metric value, and the count of value occurrences during the period.
type ReplAnalyticsTimeSeriesData {
  timestamp: DateTime!
  value: String!
  count: Int!
}

input ReplAnalyticsTimeSeriesInput {
  # The metric for which we want time series data
  metric: String!

  # Localized start for the window where the want the time series data.
  start: DateTime!

  # Number of consecutive hours for which we want results. Max 168.
  hours: Int!

  # Return results for the associated deployment Repl. Defaults to false.
  deployment: Boolean
}

# A connection to a list of Users.
type UserConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of Users.
  items: [User!]!
}

enum UserSubscriptionTypeEnum {
  HACKER
  HACKER_PRO
}

type CoverImage {
  url: String!
  offsetY: Int!
}

type UserPresenceStatus {
  # Datetime for last time this user was seen on the site
  lastSeen: DateTime

  # Whether the user should be considered online
  isOnline: Boolean!
}

# Bounty-related stats for a user
type BountyUserStats {
  completedBountiesCount: Int!
  inProgressBountiesCount: Int!
  postedBountiesCount: Int!
  numHunterReviews: Int!
  averageHunterRating: Float!
}

# Information about a user's activity in Bounties
type BountyInfo {
  # Stats about a user's activity in Bounties
  stats: BountyUserStats!

  # Bounty reviews for a given user
  hunterReviews(after: String, count: Int): BountyHunterReviewsOutput!

  # How much a user has earned in Cycles
  hunterEarnings: BountyHunterEarnings!

  # How much a user has spent on Bounties in Cycles
  posterSpending: BountyPosterSpending!
}

union BountyHunterReviewsOutput =
    UserError
  | UnauthorizedError
  | BountyHunterReviewConnection

# A connection to a list of BountyHunterReviews.
type BountyHunterReviewConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of BountyHunterReviews.
  items: [BountyHunterReview!]!
}

# A review of a Bounty hunter by a Bounty Poster
type BountyHunterReview {
  id: Int!
  communicationRating: Int!
  qualityRating: Int!
  timelinessRating: Int!
  reviewText: String
  bounty: Bounty
  reviewedUser: User
  reviewingUser: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# Represents a request for work in exchange for cycles
type Bounty {
  id: Int!
  title: String!
  slug: String!
  description: String!
  cycles: Int!
  deadline: Date!
  status: bountiesstatusEnumType!
  isUnlisted: Boolean!
  timeCreated: Date!

  # A preview of the Bounty's description with all markdown syntax stripped away
  descriptionPreview: String!
  solverPayout: Int!
  fee: Int!
  isCurrentUserBountyPoster: Boolean!
  isCurrentUserBountySolver: Boolean!
  hasCurrentUserApplied: Boolean!

  # The current user application for this bounty, if it exists
  currentUserApplication: BountyApplication
  canCurrentUserCancel: Boolean!
  user: User
  solver: User

  # If it exists, review of the hunter for completing this Bounty
  bountyHunterReview: BountyHunterReview
  walletId: String
  contactInfo: String
  contactMethod: BountyContactMethod
  acceptedApplication: BountyApplication

  # Count of applications that are publicly visible (i.e. those not awaiting moderation)
  applicationCount: Int!
  latestSubmission: BountySubmission
  submissions: [BountySubmission!]!
  events(count: Int, after: String): BountyEventConnection
}

enum bountiesstatusEnumType {
  open
  in_progress
  completed
  canceled
}

# Represents an application to work on a Bounty
type BountyApplication {
  id: Int!
  content: String!
  status: bounty_applicationsstatusEnumType!
  timeCreated: DateTime!
  timeUpdated: DateTime!

  # The applicant's contact info, which is only viewable by the Bounty poster and the applicant
  contactInfo: String

  # The Bounty that this application is for
  bounty: Bounty

  # The user who created this application
  user: User

  # True if the current user is the user who created this application
  isCurrentUserApplicant: Boolean!

  # True if the current user can remove this application
  canCurrentUserRemoveApplication: Boolean!

  # True if the current user can send a chat message, false otherwise
  canCurrentUserSendChatMessage: Boolean!

  # True if the current user can view the chat for this bounty application
  canCurrentUserViewChat: Boolean!

  # The number of unread chat messages for this bounty application
  unreadChatMessageCount: Int!
}

enum bounty_applicationsstatusEnumType {
  accepted
  rejected
  not_reviewed
  awaiting_moderation
}

enum BountyContactMethod {
  email
  discord
}

# Represents a submission for a Bounty
type BountySubmission {
  id: Int!
  content: String!
  bounty: Bounty
  repls: [Repl!]!
  review: BountySubmissionReview
  user: User
}

# Represents a review of a Bounty submission
type BountySubmissionReview {
  id: Int!
  isAccepted: Boolean!
  content: String
  submission: BountySubmission
}

# A connection to a list of BountyEvents.
type BountyEventConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of BountyEvents.
  items: [BountyEvent!]!
}

# Represents an event that happened to a Bounty
union BountyEvent =
    BountyApplicationReviewedEvent
  | BountyStateChangeEvent
  | BountyWorkReviewedEvent
  | BountyWorkSubmittedEvent
  | BountyUpdatesEvent
  | BasicBountyEvent

# An event for when a bounty application is reviewed. currently only fired when application is accepted
type BountyApplicationReviewedEvent {
  id: Int!
  eventType: bounty_eventseventTypeEnumType!
  timeCreated: Date!
  bounty: Bounty
  user: User
  isAccepted: Boolean!
}

enum bounty_eventseventTypeEnumType {
  application_submitted
  application_reviewed
  work_submitted
  work_reviewed
  bounty_updated
  bounty_abandoned
  bounty_canceled
  bounty_state_change
}

# Represents a bounty changing between open, in progress, closed
type BountyStateChangeEvent {
  id: Int!
  eventType: bounty_eventseventTypeEnumType!
  timeCreated: Date!
  bounty: Bounty

  # null if this is the first state change (bounty opened)
  oldStatus: String
  newStatus: String!
}

# Represents a bounty submission being reviewed
type BountyWorkReviewedEvent {
  id: Int!
  eventType: bounty_eventseventTypeEnumType!
  timeCreated: Date!
  bounty: Bounty
  content: String!
  isAccepted: Boolean!
}

# Represents someone submitting work for a bounty
type BountyWorkSubmittedEvent {
  id: Int!
  eventType: bounty_eventseventTypeEnumType!
  timeCreated: Date!
  bounty: Bounty
  user: User
  content: String!
  repls: [Repl!]!
  bountySubmission: BountySubmission
    @deprecated(
      reason: "use event field directly instead of querying this type"
    )
}

# Represents an update to a bounty
type BountyUpdatesEvent {
  id: Int!
  eventType: bounty_eventseventTypeEnumType!
  timeCreated: Date!
  bounty: Bounty
  before: BountyUpdate!
  after: BountyUpdate!
}

type BountyUpdate {
  title: String!
  description: String!
  cycles: Int!
  deadline: Date!
  contactInfo: String
}

# Represents a bounty event
type BasicBountyEvent {
  id: Int!
  eventType: bounty_eventseventTypeEnumType!
  timeCreated: Date!
}

type BountyHunterEarnings {
  # Approximate earnings in Cycles
  approximateCyclesEarned: Int!
}

type BountyPosterSpending {
  # Approximate amount spent on Bounties in Cycles
  approximateCyclesSpent: Int!
}

# A user gate (feature flag).
type UserGate {
  type: UserGateValueType!
  controlName: String!
  value: StringNumberBoolean!
}

enum UserGateValueType {
  boolean
  string
  number
  json
}

# A type that can be a string, number, or boolean
scalar StringNumberBoolean

# A feature flag
type Flag {
  id: String!
  type: UserFlagValueType!
  value: FlagValueType!
}

enum UserFlagValueType {
  boolean
  string
  number
  json
}

# The type that a feature flag can assume; at the moment: string, number, or boolean
scalar FlagValueType

# A tour and its seen status
type TourSeen {
  id: String!
  seen: Boolean!
}

enum UserUpdateColumns {
  EMAIL
  USERNAME
}

# An object for keeping user state
type UserState {
  id: Int!
  skillLevel: String
  interestedIn: String
  languagesInterestedIn: [Language!]!
}

# Grouped Search results for authenticated user
type UserSearchResults {
  repls(query: String, count: Int): [Repl!]!
  posts(query: String, count: Int): [Post!]! @deprecated
  languages(query: String, count: Int): [Language!]! @deprecated
}

# An object for keeping user auth from diffrent providers
type UserAuth {
  accessToken: String
  provider: UserAuthProviders!
}

enum UserAuthProviders {
  GOOGLE
  GITHUB
  FACEBOOK
  APPLE
}

# Possible results when querying currentUser.repositories
union RepositoriesOutput = RepositoryConnection | UserAuthProviderError

# A connection to a list of Repositorys.
type RepositoryConnection {
  # Number of repostories requested per installation
  count: Int

  # A list of Repositorys.
  items: [Repository!]!
}

# A user repository
type Repository {
  id: String!
  provider: String!
  name: String!
  nameWithOwner: String!
  ownerName: String!
  gitUrl: String!
  url: String!
  isPrivate: Boolean!
  createdAt: String!
  updatedAt: String!
  description: String
  primaryLanguage: GitHubLanguage
  starCount: Int!
  repls: [Repl!]
}

# A GitHub language
type GitHubLanguage {
  id: String!
  name: String!
  color: String
}

# A user auth provider error
type UserAuthProviderError {
  provider: UserAuthProviders!
  message: String!
}

enum RepositoryPrivacy {
  PRIVATE
  PUBLIC
}

type GitHubInfo {
  accessToken: String
  installations: [GitHubUserInstallations!]
  userInfo: GitHubUserInfo
}

type GitHubUserInstallations {
  id: String
  type: String!
  avatarUrl: String
  name: String!
}

type GitHubUserInfo {
  name: String
  username: String
  email: String
  avatarUrl: String
}

# A user's editor preferences
type EditorPreferences {
  isLayoutStacked: Boolean!
  theme: String!
  fontSize: Int!
  indentIsSpaces: Boolean!
  indentSize: Int!
  keyboardHandler: String
  wrapping: Boolean!
  codeIntelligence: Boolean!
  codeSuggestion: Boolean!
  completeCodeEngine: String
  chatEngine: String
  accessibleTerminal: Boolean!
  multiselectModifierKey: String!
  webviewAutoOpenOnPortOpened: Boolean!
  extraDelight: Boolean!
  enableGpu: Boolean!
  minimapDisplay: String!
}

# A folder of repls
type ReplFolder {
  id: String!
  userId: Int
  name: String!
  parentId: String
  timeCreated: DateTime!
  timeUpdated: DateTime!
  path: String!
  pathnames: [String!]!
  canEdit: Boolean!
  canCreateSubFolders: Boolean!
  replsCount: Int
  parent: ReplFolder
  image: String
  folderType: ReplFolderTypes
  folders(search: String): [ReplFolder!]!
  repls(
    count: Int
    order: String
    after: String
    starred: Boolean
    search: String
    languages: [String!]
  ): ReplConnection!
}

enum ReplFolderTypes {
  MULTIPLAYER
  BOOSTS
  ALWAYS_ON
  TEAM
  ALL_TEAMS
  VIRTUAL
  DEFAULT
}

enum TeamOrganizationSubscriptionTypeEnum {
  EDUCATION
  PRO
}

# A user's billing info
type BillingInfo {
  planInfo: PlanInfo
  expiration: DateTime
}

type PlanInfo {
  provider: PaymentProviderEnum!

  # The unit amount in cents to be charged, represented as a whole integer if possible
  amount: Int
  nextPaymentDue: DateTime
  description: String!
  interval: String
  cancelAt: DateTime
  coupon: DiscountInfo
}

enum PaymentProviderEnum {
  stripe
  apple
  google
}

type DiscountInfo {
  amount: Int
  percent: Int
  endAt: DateTime
}

# A group of template repls or languages
type CreateReplOptionGroup {
  # The name of the group
  name: String!

  # A list of template repls or languages
  options: [CreateReplOptions!]!
}

union CreateReplOptions = Language | Repl

# Information about Cycles related entities for the current user
type Cycles {
  # True if the user has a Cycles subscription
  hasSubscription: Boolean!

  # The user's active Cycles Subscription, if they have one
  subscription: CurrentUserActiveCyclesSubscription

  # Cycles balance
  balance: CyclesBalanceOutput!

  # Paginated transactions for the current user
  transactions(after: String, count: Int): CyclesTransactionConnection

  # Forecasts for a user's cycles
  forecast(
    # Days from current time to calculate the forecast
    daysFromNow: Int!
  ): CyclesForecastOutput!
}

union CurrentUserActiveCyclesSubscription = NotFoundError | CyclesSubscription

# A user's subscription for recurring Cycles purchases
type CyclesSubscription {
  id: Int!
  cycles: Int!

  # The next time the subscription will be fulfilled if the subscription is active
  nextRefillDate: DateTime
}

union CyclesBalanceOutput =
    UnauthorizedError
  | ServiceUnavailable
  | CyclesBalance

type CyclesBalance {
  cycles: Float!
  lastUpdated: DateTime!
}

# A connection to a list of CyclesTransactions.
type CyclesTransactionConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of CyclesTransactions.
  items: [CyclesTransaction!]!
}

type CyclesTransaction {
  # Transaction ID
  id: String!

  # User ID for the party whose balance is affected by the transaction
  principal_user_id: Int!

  # Number of cycles
  cycles: Int!

  # The type of transaction (e.g. purchased, granted, retired, redeemed)
  type: CyclesTransactionTypeEnumType!

  # When the transaction was created
  time_created: DateTime

  # Contextual information about the transaction: transaction group, assosciated repl, database table
  metadata: Metadata

  # Category the transaction falls under
  category: CategoryEnumType

  # What the transaction is used for on the product
  category_sub_type: CategorySubTypeEnumType
}

enum CyclesTransactionTypeEnumType {
  purchased
  granted
  redeemed
  retired
  transferred
  fee_charged
  cashed_out
  earned
}

type Metadata {
  system: MetadataSystemEnumType
  relation: MetadataRelationEnumType
}

enum MetadataSystemEnumType {
  web_postgres
}

enum MetadataRelationEnumType {
  bounties
  external_transactions
  repl_order
  user_order
  tips
}

enum CategoryEnumType {
  marketplace
  uncategorized
  credits
  earnings
  adjustments
  power_ups
}

enum CategorySubTypeEnumType {
  bounty
  transferred
  purchased
  granted
  redeemed
  retired
  earned
  fee_charged
  cashed_out
  uncategorized
  boost
  always_on
  ghostwriter
  private_repl
  gpu
  tips
  egress
  hosting_tier
}

union CyclesForecastOutput =
    UserError
  | UnauthorizedError
  | ServiceUnavailable
  | CyclesForecast

type CyclesForecast {
  # Indicates if the user's current Cycles balance is enough to fulfill their currently active Power Ups up to and including the specified date
  hasSufficientCycles: Boolean!

  # The amount of Cycles that would be spent according to the forecast
  estimatedCyclesSpend: Int!
}

type ReplContinent {
  # The continent's name
  name: String!

  # The continent ID
  id: ReplContinentId!
}

enum ReplContinentId {
  NA
  ASIA
}

# A version of a custom theme
type ThemeVersion {
  id: Int!
  saturation: Float!
  lightness: Float!
  description: String!
  timeUpdated: DateTime!
  hue: Float
  customTheme: CustomTheme!
  values: ThemeValues!
}

# The root type for a custom theme
type CustomTheme {
  id: Int!
  title: String!
  slug: String!

  # The URL for a given theme. Useful for linking to the cover page for that theme. Returns null if the author was deleted or banned.
  url: String

  # The URL for a given theme's edit page. Returns null if the author was deleted or banned.
  editPageUrl: String
  latestThemeVersion: ThemeVersion
  draftThemeVersion: ThemeVersion
  author: User
  colorScheme: CustomThemeColorScheme!
  status: CustomThemeStatus!

  # The number of users that have installed the theme.
  numInstalls: Int!

  # Whether the custom theme has unpublished changes. This field will always resolve to false if the current user is not the theme author
  hasUnpublishedChanges: Boolean!

  # Whether current user is author of the theme
  isCurrentUserThemeAuthor: Boolean!

  # Whether current user has the theme installed. It is important to note that a Theme is considered installed if the current user is the theme author even though there is no InstalledThemes entry.
  isInstalledByCurrentUser: Boolean!

  # Whether current user has the theme installed and can upgrade to a new version of the theme. This will always be false for theme authors because they are always on the latest version. This will also be false for users without the theme installed.
  canCurrentUserInstallUpdate: Boolean!

  # Returns the version of a theme that the current user has installed, or null if the theme is not installed by the current user. If the user is the author, they will get the draft version if one exists, or the latest release version.
  currentUserInstalledThemeVersion: ThemeVersion

  # Users who have tipped this Theme the most
  topTippers: [TipperUser!]!

  # Total tips received by this theme, inclusive of fees (if any), in cycles
  totalCyclesTips: Int!

  # Total tips received by this theme from a given user (by ID), inclusive of fees (if any), in cycles. Null if user is not logged in.
  currentUserTotalTips: Int
}

enum CustomThemeColorScheme {
  light
  dark
}

enum CustomThemeStatus {
  hidden
  public
  deleted
}

# The values from a customTheme
type ThemeValues {
  global: ThemeValuesGlobal!
  editor: ThemeValuesEditor!
}

# The global Theme values
type ThemeValuesGlobal {
  backgroundRoot: String!
  backgroundDefault: String!
  backgroundHigher: String!
  backgroundHighest: String!
  backgroundOverlay: String!
  foregroundDefault: String!
  foregroundDimmer: String!
  foregroundDimmest: String!
  outlineDimmest: String!
  outlineDimmer: String!
  outlineDefault: String!
  outlineStronger: String!
  outlineStrongest: String!
  accentPrimaryDimmest: String!
  accentPrimaryDimmer: String!
  accentPrimaryDefault: String!
  accentPrimaryStronger: String!
  accentPrimaryStrongest: String!
  accentPositiveDimmest: String!
  accentPositiveDimmer: String!
  accentPositiveDefault: String!
  accentPositiveStronger: String!
  accentPositiveStrongest: String!
  accentNegativeDimmest: String!
  accentNegativeDimmer: String!
  accentNegativeDefault: String!
  accentNegativeStronger: String!
  accentNegativeStrongest: String!
  redDimmest: String!
  redDimmer: String!
  redDefault: String!
  redStronger: String!
  redStrongest: String!
  orangeDimmest: String!
  orangeDimmer: String!
  orangeDefault: String!
  orangeStronger: String!
  orangeStrongest: String!
  yellowDimmest: String!
  yellowDimmer: String!
  yellowDefault: String!
  yellowStronger: String!
  yellowStrongest: String!
  limeDimmest: String!
  limeDimmer: String!
  limeDefault: String!
  limeStronger: String!
  limeStrongest: String!
  greenDimmest: String!
  greenDimmer: String!
  greenDefault: String!
  greenStronger: String!
  greenStrongest: String!
  tealDimmest: String!
  tealDimmer: String!
  tealDefault: String!
  tealStronger: String!
  tealStrongest: String!
  blueDimmest: String!
  blueDimmer: String!
  blueDefault: String!
  blueStronger: String!
  blueStrongest: String!
  blurpleDimmest: String!
  blurpleDimmer: String!
  blurpleDefault: String!
  blurpleStronger: String!
  blurpleStrongest: String!
  purpleDimmest: String!
  purpleDimmer: String!
  purpleDefault: String!
  purpleStronger: String!
  purpleStrongest: String!
  magentaDimmest: String!
  magentaDimmer: String!
  magentaDefault: String!
  magentaStronger: String!
  magentaStrongest: String!
  pinkDimmest: String!
  pinkDimmer: String!
  pinkDefault: String!
  pinkStronger: String!
  pinkStrongest: String!
  greyDimmest: String!
  greyDimmer: String!
  greyDefault: String!
  greyStronger: String!
  greyStrongest: String!
  brownDimmest: String!
  brownDimmer: String!
  brownDefault: String!
  brownStronger: String!
  brownStrongest: String!
  black: String!
  white: String!
}

# The editor Theme values
type ThemeValuesEditor {
  syntaxHighlighting: [ThemeEditorSyntaxHighlighting!]!
}

# An object which contains CSS styles that are applied to a given set of editor tags
type ThemeEditorSyntaxHighlighting {
  tags: [ThemeEditorTag!]!
  values: JSON!
}

# A selector for a given editor tag
type ThemeEditorTag {
  name: String!
  modifiers: [String!]
}

union CurrentUserInstalledThemesOutput =
    UserError
  | UnauthorizedError
  | InstalledThemeConnection

# A connection to a list of InstalledThemes.
type InstalledThemeConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of InstalledThemes.
  items: [InstalledTheme!]!
}

# The root type for an installed theme
type InstalledTheme {
  id: Int!
  user: User!
  themeVersion: ThemeVersion!
  customTheme: CustomTheme!
}

# Input for the current user installed themes query. If passed in, after must be a string representing a valid positive integer and count must be an integer between 0 and 100
input CurrentUserInstalledThemesInput {
  after: String
  count: Int
}

union CurrentUserAuthoredThemesOutput =
    UserError
  | UnauthorizedError
  | CustomThemeConnection

# A connection to a list of CustomThemes.
type CustomThemeConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of CustomThemes.
  items: [CustomTheme!]!
}

# Input for the current user authored themes query. If passed in, after must be a string representing a valid positive integer and count must be an integer between 0 and 100
input CurrentUserAuthoredThemesInput {
  after: String
  count: Int
}

type ReplPowerUpDescriptionType {
  # Power Up ID
  id: Int!

  # The Repl to which the Power Up relates
  repl: Repl!

  # Whether the Power Up is active
  active: Boolean!

  # The type of Power Up (e.g. boost, always on, private)
  type: ReplPowerUpTypeEnumType!

  # The SKU of the Power Up
  sku: ReplPowerUpSkuEnumType!

  # When the Power Up was last fulfilled
  time_last_fulfilled: DateTime

  # When the Power Up will be fulfilled next
  time_fulfillment_due: DateTime
}

enum ReplPowerUpTypeEnumType {
  alwaysOn
  boost
  gpu
  hosting_tier
}

enum ReplPowerUpSkuEnumType {
  alwaysOn_legacy
  alwaysOn
  boost_legacy
  gpu_k80
  boost_2cpu_2ram
  boost_4cpu_4ram
  boost_8cpu_8ram
  boost_16cpu_16ram
  unknown
  hosting_tier_e2_micro
  hosting_tier_e2_small
  hosting_tier_e2_medium
  hosting_tier_n1_custom_1_4
  hosting_tier_e2_standard_2
  hosting_tier_e2_standard_4
}

# Power Ups which relate to the user (as-compared-with repl-specific Power Ups)
type UserPowerUpDescriptionType {
  # Power Up ID
  id: Int!

  # Whether the Power Up is active
  active: Boolean!

  # The type of Power Up
  type: UserPowerUpTypeEnumType!

  # When the Power Up was last fulfilled
  time_last_fulfilled: DateTime

  # When the Power Up will be fulfilled next
  time_fulfillment_due: DateTime
}

enum UserPowerUpTypeEnumType {
  private
  ghostwriter
  neonDatabasePreview
  egress
}

union UserPowerUpsTypesOutput =
    UserError
  | UnauthorizedError
  | UserPowerUpsTypes

# State of user-scoped Power Ups
type UserPowerUpsTypes {
  ghostwriter: GhostwriterPowerUpType!
  privateRepls: PrivateReplsPowerUpType!
  neonDatabasePreview: [NeonDatabasePreviewPowerUpType!]!
  egress: [EgressPowerUpType!]!
}

# State of the Ghostwriter Power Up
type GhostwriterPowerUpType implements UserPowerUpDescriptionByType {
  # Whether the Power Up is active (irrespective of whether it is being paid for or a trial). Note that this is distinct from the "active" field on a cycles_users_orders entry, which itself denote whether the order is set to renew.
  active: Boolean!

  # If active, whether the user's access is due to a trial (rather than a paid subscription)
  isTrial: Boolean!

  # Whether the Power Up will renew (and typically result in a charge for the user)
  willRenew: Boolean!

  # If the user has (or has had) a trial, the expiry date thereof
  timeTrialExpiry: DateTime
  timeLastFulfilled: Date
  timeFulfillmentDue: Date

  # How the user is paying for this Power Up, if they are paying for it (null if they are not)
  methodOfPayment: PowerUpMethodOfPayment

  # What call-to-action to present to the user, if any. Note that some of this information can be derived through other fields on this type, but only partially so (e.g. you wouldn't be able to tell whether the user has already had a trial or not without using this field).
  CTA: PowerUpCallToActionEnumType

  # The Cycles cost that the user would incur upon purchasing the Power Up with Cycles
  cost: UserPowerUpCostDetailType

  # Which paid upgrade path to suggest for getting access to the power up.
  suggestedUpgradePath: UpgradePathEnumType

  # State of the Ghostwriter Chat metered trial
  meteredTrial: GhostwriterChatMeteredTrialStatus
}

# Power Ups which relate to the user (as-compared-with repl-specific Power Ups)
interface UserPowerUpDescriptionByType {
  # Whether the Power Up is active (irrespective of whether it is being paid for or a trial). Note that this is distinct from the "active" field on a cycles_users_orders entry, which itself denote whether the order is set to renew.
  active: Boolean!

  # If active, whether the user's access is due to a trial (rather than a paid subscription)
  isTrial: Boolean!

  # Whether the Power Up will renew (and typically result in a charge for the user)
  willRenew: Boolean!

  # If the user has (or has had) a trial, the expiry date thereof
  timeTrialExpiry: DateTime
  timeLastFulfilled: Date
  timeFulfillmentDue: Date

  # How the user is paying for this Power Up, if they are paying for it (null if they are not)
  methodOfPayment: PowerUpMethodOfPayment

  # What call-to-action to present to the user, if any. Note that some of this information can be derived through other fields on this type, but only partially so (e.g. you wouldn't be able to tell whether the user has already had a trial or not without using this field).
  CTA: PowerUpCallToActionEnumType

  # The Cycles cost that the user would incur upon purchasing the Power Up with Cycles
  cost: UserPowerUpCostDetailType

  # Which paid upgrade path to suggest for getting access to the power up.
  suggestedUpgradePath: UpgradePathEnumType
}

# A call-to-action to present to the current user
enum PowerUpCallToActionEnumType {
  # The user should be prompted to activate the feature
  ACTIVATE

  # The user has activated the feature, and an optional call-to-action can be presented to them in light of that
  ACTIVATED

  # The user should be prompted to activate the feature, however they should not be offered a trial as they already had one. We used to offer self-enrollment into Ghostwriter trials in the client. We've deprecated that feature.
  ACTIVATE_ALREADY_TRIALED
    @deprecated(reason: "No longer handled by the client")

  # The user has activated the feature in the context of a trial
  TRIAL_ONGOING

  # The user had activated the feature in the context of a trial, and the trial has expired
  TRIAL_EXPIRED
}

# The cost associated with a given Power Up
type UserPowerUpCostDetailType {
  cycles: Int!
  explanation: PowerUpCostExplanationEnumType!
}

# Which paid upgrade path to suggest to the user to activate the power up.
enum UpgradePathEnumType {
  # The user should be prompted to subscribe to Hacker to get access to this power up
  HACKER

  # The user should be prompted to subscribe to Pro to get access to this power up
  HACKER_PRO

  # The user should be prompted to buy Cycles in order to spend them on this power up to get access
  CYCLES
}

# State of the Ghostwriter Chat Metered Trial
type GhostwriterChatMeteredTrialStatus {
  messagesSentInPeriod: Int!
  cap: Int!
  hasAccessToMeteredTrial: Boolean!
}

# State of the Private Repls Power Up
type PrivateReplsPowerUpType implements UserPowerUpDescriptionByType {
  # Whether the Power Up is active (irrespective of whether it is being paid for or a trial). Note that this is distinct from the "active" field on a cycles_users_orders entry, which itself denote whether the order is set to renew.
  active: Boolean!

  # If active, whether the user's access is due to a trial (rather than a paid subscription)
  isTrial: Boolean!

  # Whether the Power Up will renew (and typically result in a charge for the user)
  willRenew: Boolean!

  # If the user has (or has had) a trial, the expiry date thereof
  timeTrialExpiry: DateTime
  timeLastFulfilled: Date
  timeFulfillmentDue: Date

  # How the user is paying for this Power Up, if they are paying for it (null if they are not)
  methodOfPayment: PowerUpMethodOfPayment

  # What call-to-action to present to the user, if any. Note that some of this information can be derived through other fields on this type, but only partially so (e.g. you wouldn't be able to tell whether the user has already had a trial or not without using this field).
  CTA: PowerUpCallToActionEnumType

  # The Cycles cost that the user would incur upon purchasing the Power Up with Cycles
  cost: UserPowerUpCostDetailType

  # Which paid upgrade path to suggest for getting access to the power up.
  suggestedUpgradePath: UpgradePathEnumType
}

# State of the Neon Database Preview Power Up
type NeonDatabasePreviewPowerUpType implements UserPowerUpDescriptionByType {
  # Whether the Power Up is active (irrespective of whether it is being paid for or a trial). Note that this is distinct from the "active" field on a cycles_users_orders entry, which itself denote whether the order is set to renew.
  active: Boolean!

  # If active, whether the user's access is due to a trial (rather than a paid subscription)
  isTrial: Boolean!

  # Whether the Power Up will renew (and typically result in a charge for the user)
  willRenew: Boolean!

  # If the user has (or has had) a trial, the expiry date thereof
  timeTrialExpiry: DateTime
  timeLastFulfilled: Date
  timeFulfillmentDue: Date

  # How the user is paying for this Power Up, if they are paying for it (null if they are not)
  methodOfPayment: PowerUpMethodOfPayment

  # What call-to-action to present to the user, if any. Note that some of this information can be derived through other fields on this type, but only partially so (e.g. you wouldn't be able to tell whether the user has already had a trial or not without using this field).
  CTA: PowerUpCallToActionEnumType

  # The cost that the user would incur upon purchasing the Power Up
  cost: UserPowerUpCostDetailType

  # Which paid upgrade path to suggest for getting access to the power up.
  suggestedUpgradePath: UpgradePathEnumType
  neonDatabaseName: String!
  connectedRepls: [Repl!]!
}

# State of the Egress Power Up
type EgressPowerUpType implements UserPowerUpDescriptionByType {
  # Whether the Power Up is active (irrespective of whether it is being paid for or a trial). Note that this is distinct from the "active" field on a cycles_users_orders entry, which itself denote whether the order is set to renew.
  active: Boolean!

  # If active, whether the user's access is due to a trial (rather than a paid subscription)
  isTrial: Boolean!

  # Whether the Power Up will renew (and typically result in a charge for the user)
  willRenew: Boolean!

  # If the user has (or has had) a trial, the expiry date thereof
  timeTrialExpiry: DateTime
  timeLastFulfilled: Date
  timeFulfillmentDue: Date

  # How the user is paying for this Power Up, if they are paying for it (null if they are not)
  methodOfPayment: PowerUpMethodOfPayment

  # What call-to-action to present to the user, if any. Note that some of this information can be derived through other fields on this type, but only partially so (e.g. you wouldn't be able to tell whether the user has already had a trial or not without using this field).
  CTA: PowerUpCallToActionEnumType

  # The Cycles cost that the user would incur upon purchasing the Power Up with Cycles
  cost: UserPowerUpCostDetailType

  # Which paid upgrade path to suggest for getting access to the power up.
  suggestedUpgradePath: UpgradePathEnumType

  # The SKU associated with the Power Up
  sku: EgressAddOnSku

  # The time at which the user purchased the Power Up
  timePurchased: DateTime
}

enum EgressAddOnSku {
  egress_goval_10_gib
  egress_goval_50_gib
  egress_goval_100_gib
  egress_goval_500_gib
  egress_goval_1000_gib
}

union UserPowerUpCost = UnauthorizedError | UserError | UserPowerUpCostsType

# The cost associated with various Power Ups for the user
type UserPowerUpCostsType {
  # Cost for making repls owned by the user private
  private: UserPowerUpCostDetailType!

  # Cost for using Ghostwriter
  ghostwriter: UserPowerUpCostDetailType!
}

union CurrentUserPricesUpdateOptionOutput =
    UserError
  | UnauthorizedError
  | CurrentUserPricesUpdateOptionOutputObject

type CurrentUserPricesUpdateOptionOutputObject {
  option: CurrentUserPricesUpdateOption
}

enum CurrentUserPricesUpdateOption {
  legacy_hacker
  legacy_cycles
  general
}

union UserCourseOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | UserCourse

union UserCourseLessonOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | UserCourseLesson

union CurrentUserReplPowerUpsByMethodOfPaymentOutput =
    UnauthorizedError
  | CurrentUserReplPowerUpsByMethodOfPaymentSuccess

type CurrentUserReplPowerUpsByMethodOfPaymentSuccess {
  powerUps: [RenderedPowerUpType!]!
}

type RenderedPowerUpType {
  powerUpType: ReplPowerUpTypeEnumType!
  methodOfPayment: PowerUpMethodOfPayment!
  repl: Repl!
  sku: ReplPowerUpSkuEnumType!
}

union CurrentUserEgressOutput =
    UnauthorizedError
  | UserError
  | UserEgressSummary

# A user's egress consumption summary.
type UserEgressSummary {
  monthly: MonthlyEgressSummary!
}

# Summary of monthly egress consumption, at account and Repl levels.
type MonthlyEgressSummary {
  # Beginning of the month captured by the summary
  start: DateTime!

  # The date on which the limit resets
  resets: String!

  # The number of bytes allotted to the account for this month. Represented as a string because GiB can easily exceed int32.
  limit: String!

  # The number of bytes used by the account for this month. Represented as a string because GiB can easily exceed int32.
  usage: String!

  # Whether the limit is currently enforced.
  isEnforced: Boolean!

  # Whether egress is currently throttled.
  isThrottled: Boolean!

  # Whether the user should be prompted to upgrade.
  showUpgrade: Boolean!

  # Egress consumption for this month broken out by Repl.
  perRepl: [ReplEgressSummary!]!
}

# Summary of a Repl's monthly egress consumption.
type ReplEgressSummary {
  # The Repl for which we are reporting monthly egress.
  repl: Repl!

  # The number of bytes used by the Repl for this month. Represented as a string because GiB can easily exceed int32.
  usage: String!

  # Percentage of usage consumed by this Repl.
  percentage: Float!
}

# Information related to a user's storage utilization.
type StorageInfo {
  # A user's storage utilization summary.
  accountStorageUtilization: AccountStorageUtilizationOutput!

  # A user's storage quota.
  storageQuota: StorageQuotaOutput!

  # A user's storage quota status.
  storageQuotaStatus: StorageQuotaEnum!
    @deprecated(
      reason: "If errors are thrown in this resolver the upstream UI may not be able to handle them. Use storageQuotaStatus2 instead."
    )

  # A user's storage quota status.
  storageQuotaStatus2: StorageQuotaStatusOutput!
}

union AccountStorageUtilizationOutput =
    UnauthorizedError
  | ServiceUnavailable
  | AccountStorageUtilization

# A user's storage utilization summary.
type AccountStorageUtilization {
  # Storage utilization broken out by Repl.
  perRepl: [ReplStorageUtilization!]!

  # Total bytes of storage used by the account. Represented as a string because GiB can easily exceed int32.
  total: String!
}

# Summary of a Repl's storage utilization.
type ReplStorageUtilization {
  # The Repl for which we are reporting storage utilization.
  repl: Repl!

  # The number of bytes used by the Repl for this month. Represented as a string because GiB can easily exceed int32.
  usage: String!

  # Percentage of usage consumed by this Repl.
  percentage: Float!
}

union StorageQuotaOutput = ServiceUnavailable | StorageQuota

# A user's storage quota.
type StorageQuota {
  # Total bytes in the user's quota. Represented as a string to get around GraphQL's max int size. Returns "0" if not set.
  quota: String!
}

enum StorageQuotaEnum {
  ExceedingQuota
  ApproachingQuota
  UnderQuota
}

union StorageQuotaStatusOutput = ServiceUnavailable | StorageQuotaStatus

# A user's storage quota status
type StorageQuotaStatus {
  # Whether a user is under, approaching, or exceeding their storage quota
  status: StorageQuotaEnum!
}

union UserPaymentMethod = UnauthorizedError | PaymentMethod

# A payment method
type PaymentMethod {
  # The ID of the payment method
  id: Int!

  # The last 4 digits of the card
  last4: Int!

  # The month the card expires
  expirationMonth: Int!

  # The year the card expires
  expirationYear: Int!

  # The ID of the payment method in the payment provider
  externalId: String!

  # Whether the payment method has been saved in our database. If false, this is a candidate card that has not been saved yet.
  isSaved: Boolean!
}

union UserCyclesAutoRefillConfigurationOutput =
    UnauthorizedError
  | CyclesAutoRefillConfiguration

# Cycles Auto-Refill configuration for a user
type CyclesAutoRefillConfiguration {
  id: Int!
  enabled: Boolean!
  refillAmount: Int!
  monthlyBudget: Int
}

enum RecentReplsFilter {
  own
  multiplayer
}

type Keybindings {
  keybindings: JSON
}

enum KeybindingsEnvironmentEnum {
  mobile_app
  mobile_web
  desktop_app
  desktop_web
}

enum KeybindingsPlatformEnum {
  linux
  mac
  windows
}

union ReplQueryOutput = Repl | ReplRedirect | SubscriptionExpiredError

# Redirect information for a Repl that has been renamed or owned by user
type ReplRedirect {
  replUrl: String!
  repl: Repl
}

# A user can no longer access their Repl because it is private and they are no longer subscribed
type SubscriptionExpiredError {
  replId: String!
  title: String
  isOwner: Boolean!
}

union TeamOrganizationOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | TeamOrganization

# If a user has seen a given tour.
type ToursSeenQueryResult {
  seen: Boolean!
}

union TeamOutput = Team | UserError

union BoardReports = UnauthorizedError | BoardReportConnection

# A connection to a list of BoardReports.
type BoardReportConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of BoardReports.
  items: [BoardReport!]!
}

# A report on a post or comment
type BoardReport {
  id: Int!
  reportedUserId: Int
  reason: String
  resolved: Boolean!
  timeCreated: Date!
  isEscalated: Boolean
  creator: User
  reportedUser: User
  type: String!
  post: Post
  comment: Comment
  replComment: ReplComment
  bounty: Bounty
  bountyApplication: BountyApplication
  customTheme: CustomTheme
  repl: Repl
}

# Input type for board reports query
input BoardReportsInputType {
  after: Int
  limit: Int
  resolved: Boolean
  escalated: Boolean
  target: BoardReportsTargetType
  order: BoardReportsOrderType
  reporter: Int
}

enum BoardReportsTargetType {
  post
  comment
  repl
  replComment
  reportedUser
  bounty
  bountyApplication
  customTheme
}

enum BoardReportsOrderType {
  newest
  oldest
}

# A connection to a list of Notifications.
type NotificationConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of Notifications.
  items: [Notification!]!
}

union Notification =
    MentionedInPostNotification
  | MentionedInCommentNotification
  | RepliedToCommentNotification
  | RepliedToPostNotification
  | AnswerAcceptedNotification
  | MultiplayerJoinedEmailNotification
  | MultiplayerJoinedLinkNotification
  | MultiplayerInvitedNotification
  | MultiplayerOverlimitNotification
  | WarningNotification
  | TeamInviteNotification
  | TeamOrganizationInviteNotification
  | BasicNotification
  | TeamTemplateSubmittedNotification
  | TeamTemplateReviewedStatusNotification
  | AnnotationNotification
  | EditRequestCreatedNotification
  | EditRequestAcceptedNotification
  | ReplCommentCreatedNotification
  | ReplCommentReplyCreatedNotification
  | ReplCommentMentionNotification
  | ThreadNotification
  | NewFollowerNotification
  | BountyApplicationReviewedNotification
  | BountyNewApplicationNotification
  | BountyNewSubmissionNotification
  | BountySubmissionReviewedNotification
  | BountyChatMessageNotification
  | TipReceivedNotification
  | EgressLimitNotification

# Notification for when a user is at-metioned in a post
type MentionedInPostNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
  post: Post
}

# Notification for when a user is at-metioned in a comment
type MentionedInCommentNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
  comment: Comment
}

# Notification for when a user's comment has been replied to
type RepliedToCommentNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
  comment: Comment
}

# Notification for when a user's post is commented on
type RepliedToPostNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
  comment: Comment
}

# Notification for when a user's comment was marked as the answer
type AnswerAcceptedNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
  post: Post
}

# Notification for when a user joined a multiplayer session via email invite
type MultiplayerJoinedEmailNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# Notification for when a user joined a multiplayer session via email link
type MultiplayerJoinedLinkNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# Notification for when a user gets an invite to collab on a multiplayer repl
type MultiplayerInvitedNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# Notification for when a user tried to join a multiplayer session but couldnt due to limits
type MultiplayerOverlimitNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# Notification for when a user is warned.
type WarningNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# Notification for when a user is invited to a team.
type TeamInviteNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
  invite: TeamInvite
}

# Notification for when a user is invited to an organization.
type TeamOrganizationInviteNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
  invite: TeamOrganizationInvite
}

# The default Replit Notification type
type BasicNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# Notification for when a user submits a project repl
type TeamTemplateSubmittedNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
  repl: Repl
}

# Notification for when a user's Repl submission has been marked as reviewed, or marked as no longer reviewed
type TeamTemplateReviewedStatusNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
  repl: Repl
}

# Notification for when a user receives an annotation
type AnnotationNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# A user has requested to edit a repl
type EditRequestCreatedNotification {
  id: Int!
  url: String!
  seen: Boolean!
  creator: User
  editRequest: EditRequest
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# A request to edit a repl
type EditRequest {
  id: Int!
  timeCreated: DateTime!
  timeUpdated: DateTime!
  status: EditRequestStatus
  requester: User
  repl: Repl
}

enum EditRequestStatus {
  PENDING
  ACCEPTED
  DENIED
}

# A user accepted an edit request
type EditRequestAcceptedNotification {
  id: Int!
  url: String!
  seen: Boolean!
  creator: User
  editRequest: EditRequest
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# A comment was made on a repl
type ReplCommentCreatedNotification {
  id: Int!
  url: String!
  seen: Boolean!
  creator: User
  replComment: ReplComment
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# A comment was replied to
type ReplCommentReplyCreatedNotification {
  id: Int!
  url: String!
  seen: Boolean!
  creator: User
  replComment: ReplComment
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# A user was mentioned in a Repl comment or reply
type ReplCommentMentionNotification {
  id: Int!
  url: String!
  seen: Boolean!
  creator: User
  replComment: ReplComment
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# Notification for when a user receives an update on their thread
type ThreadNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
  participants: [User!]!
  thread: AnnotationAnchor
}

# notification for when you gain a new follower
type NewFollowerNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# The poster has reviewed an application
type BountyApplicationReviewedNotification {
  id: Int!
  url: String!
  seen: Boolean!
  creator: User
  isAccepted: Boolean
  bounty: Bounty
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# A user applied to a bounty
type BountyNewApplicationNotification {
  id: Int!
  url: String!
  seen: Boolean!
  creator: User
  bounty: Bounty
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# A new submission was made for a bounty
type BountyNewSubmissionNotification {
  id: Int!
  url: String!
  seen: Boolean!
  creator: User
  bounty: Bounty
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# Bounty poster has reviewed a submission
type BountySubmissionReviewedNotification {
  id: Int!
  url: String!
  seen: Boolean!
  creator: User
  bounty: Bounty
  isAccepted: Boolean
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# A user has sent a message or messages in a bounty chat
type BountyChatMessageNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
  bounty: Bounty
  unreadCount: Int
  message: BountyChatMessage
}

# Represents a message in a Bounty chat
type BountyChatMessage {
  id: Int!
  message: String!
  timeCreated: DateTime!
  timeUpdated: DateTime!

  # The BountyApplication that this message is for
  bountyApplication: BountyApplication

  # The User that sent this message
  user: User
}

# A user is notified after having received a tip
type TipReceivedNotification {
  id: Int!
  url: String!
  seen: Boolean!
  timeCreated: DateTime!
  timeUpdated: DateTime!
  tip: Tip
}

# Represents a tip transaction between a tipper and a creator
type Tip {
  id: Int!
  amount: Int!
  timeCreated: Date!
  fee: Int!
  sender: User!
  recipient: User!
  repl: Repl
}

# A user is notified when they are approaching or have reached their monthly egress limit.
type EgressLimitNotification {
  id: Int!
  url: String!
  seen: Boolean!
  variant: notificationsvariantEnumType
  timeCreated: DateTime!
  timeUpdated: DateTime!
  limitGib: Float!
  percentage: Float!
}

enum notificationsvariantEnumType {
  mentioned_in_post
  mentioned_in_comment
  replied_to_post
  replied_to_comment
  answer_accepted
  multiplayer_joined_email
  multiplayer_joined_link
  multiplayer_invited
  multiplayer_overlimit
  warning
  new_achievement_unlocked
  team_subscription
  team_member_limit
  team_template_published
  team_template_reviewed_status
  team_invite
  team_organization_invite
  team_member_joined
  team_template_submitted
  new_annotation_mention
  new_annotation_message
  edit_request_created
  edit_request_accepted
  repl_comment_created
  repl_comment_reply_created
  repl_comment_mention
  thread_update
  new_follower
  bounty_new_application
  bounty_application_reviewed
  bounty_new_submission
  bounty_submission_reviewed
  bounty_chat_message
  tip_received
  egress_approaching_limit
  egress_reached_limit
}

# An object for fields restricted to admins
type Admin {
  user: User!
  boardTrendingAlgorithmSettings: BoardTrendingAlgorithmSettings!
}

# Settings for post + comment trending algorithm
type BoardTrendingAlgorithmSettings {
  id: String!
  postsExponent: Float!
  postsCommentWeight: Float!
  commentsExponent: Float!
}

type CluiQuery {
  # Admin CLUI operations
  admin: AdminCluiQuery

  # Staff CLUI operations
  staff: StaffCluiQuery

  # Manage your account
  account: UserCliAccountQuery

  # Moderator CLUI operations
  moderator: ModeratorCluiQuery

  # List and restore deleted repls and folders
  trash: TrashQuery

  # View and manage your teams
  team: TeamQuery

  # View and manage extensions you've made
  extension: ExtensionQuery
}

type AdminCluiQuery {
  # View, impersonate, ban, etc.
  user: AdminCliUserQuery

  # Manage site settings
  site: AdminCliSiteQuery

  # Manage user roles
  roles: AdminCliRolesQuery

  # View a team organization
  team: AdminTeamOrgQuery

  # Manage site banner
  banners: AdminCliBannersQuery

  # Set app wide key/value
  appEnv: AdminCliAppEnvQuery

  # Configure templates
  templates: AdminCliTemplatesQuery

  # View and publish curriculum hub content
  curriculum: AdminCurriculumHubQuery

  # Configure organizations
  org: AdminCliBillingOrgsQuery

  # Support tools
  support: AdminCliSupportQuery

  # Configure subscriptions
  subscriptions: AdminCliSubscriptionsQuery

  # Configure community
  community: AdminCliCommuniyQuery

  # View and update manually curated content for trending
  curation: ManualCurationQuery

  # View and manage extensions on Replit
  extension: AdminCliExtensionQuery
}

type AdminCliUserQuery {
  # View user info
  view(
    # User's username or email
    user: String!
  ): CluiOutput

  # View and manage users' Cycles balances
  cycles: AdminCliUserCyclesQuery
}

union CluiOutput =
    CluiSuccessOutput
  | CluiMarkdownOutput
  | CluiTableOutput
  | CluiComponentOutput
  | CluiErrorOutput

type CluiSuccessOutput {
  message: String!
  json: JSON
}

type CluiMarkdownOutput {
  markdown: String!
}

type CluiTableOutput {
  columns: [CluiTableColumn!]!
  rows: [JSON!]!
}

type CluiTableColumn {
  label: String!
  key: String!
}

type CluiComponentOutput {
  component: String!
}

type CluiErrorOutput {
  error: String!
  json: JSON
}

type AdminCliUserCyclesQuery {
  # Get a user's Cycles balance.
  balance(
    # The username or email of the user
    username: String!
  ): CluiOutput
}

type AdminCliSiteQuery {
  # Anyone who loaded the client before the set date will be asked to reload
  getLastUpdateTime: CluiOutput

  # Gets the Heroku slug commit version
  version: CluiOutput
}

type AdminCliRolesQuery {
  # View roles for a user
  view(
    # User's username or email
    user: String!
  ): CluiOutput
}

type AdminTeamOrgQuery {
  # View team members
  viewTeamMembers(
    # team name
    team: String!
  ): CluiOutput
}

type AdminCliBannersQuery {
  # View latest unresolved banner
  view: CluiOutput
}

type AdminCliAppEnvQuery {
  # List app environment variables
  list: CluiOutput
}

type AdminCliTemplatesQuery {
  # View and update beta templates
  beta: CluiOutput

  # View and update associations between languages and template repls
  languages: CluiOutput

  # View and update template Repl categories
  categories: CluiOutput

  # View and manage template categories
  categories2: AdminCliTemplatesCategoriesQuery

  # Approve Template Repl submissions.
  submissions: CluiOutput
}

type AdminCliTemplatesCategoriesQuery {
  # Add or edit a template category.
  view: CluiOutput

  # Assign template categories to Template Repls.
  assign: CluiOutput
}

type AdminCurriculumHubQuery {
  # View curriculum
  viewCurriculum(
    # Curriculum url slug
    slug: String
  ): CluiOutput
}

type AdminCliBillingOrgsQuery {
  # Show all organizations a user is a member of and all members of those organizations.
  view(
    # Team or user name
    teamOrUserName: String!
  ): CluiOutput
}

type AdminCliSupportQuery {
  # send emails to all unverified users
  verifyEduUsers: CluiOutput

  # View user and Repl data for debugging (and tickets)
  info(
    # a username, userid, email, replid, or the link to a Repl (prefix with `https://`, can be repl.co or repl.com)
    userOrRepl: String!

    # if true, userOrRepl is a user id
    isUserId: Boolean
  ): CluiOutput
}

type AdminCliSubscriptionsQuery {
  # View subscriptions by username or organization ID
  view(
    # username or email
    username: String

    # organization ID
    orgId: Int
  ): CluiOutput
}

type AdminCliCommuniyQuery {
  # Edit trending algorithm
  algorithm: CluiOutput
}

type ManualCurationQuery {
  # View Trending Repl picks
  list: CluiOutput
}

type AdminCliExtensionQuery {
  # View extensions people have created. Returns all extensions by default
  view(
    # The creator's @username or id. (prefix with @ to search by username)
    creator: String
  ): CluiOutput
}

type StaffCluiQuery {
  # Manage bounties and bounty-related data
  bounties: StaffBountiesQuery
}

type StaffBountiesQuery {
  # Export the HTML body of the bounties email reminder to send to Hunters
  emailReminderExport: CluiOutput

  # Review a list of Bounty Applications that need to be moderated
  applicationReviewQueue: CluiOutput
}

type UserCliAccountQuery {
  # View warnings you have been issued.
  viewWarns: CluiOutput
}

type ModeratorCluiQuery {
  # View Repl Talk bans
  viewBans: CluiOutput

  # Manage a post.
  post: ModeratorCliPostQuery

  # Ban, warn, view-warns, etc.
  user: ModeratorCliUserQuery

  # View moderator audits
  audit: ModeratorCliAuditQuery
}

type ModeratorCliPostQuery {
  # View a post/comments voters.
  showVotes(
    # The post's id
    postId: Int

    # The comment's id
    commentId: Int
  ): CluiOutput
}

type ModeratorCliUserQuery {
  # View a users warnings.
  viewWarns(
    # User's username or email
    user: String!
  ): CluiOutput
}

type ModeratorCliAuditQuery {
  # View the moderator audit log.
  viewAudit(
    # The creator of the action
    creator: String

    # The model the audit is for
    model: ModeratorAuditModels

    # The type of the action
    actionType: ModeratorAuditActionType

    # The page of audits
    page: Int

    # What order to show the results in
    order: ModeratorAuditSorting
  ): CluiOutput

  # View the moderator audit log.
  viewItem(id: Int!): CluiOutput
}

# The accessible models for the moderator audit.
enum ModeratorAuditModels {
  BannedBoardUsers
  Warning
  Comments
  Posts
  BoardReports
}

enum ModeratorAuditActionType {
  CREATE
  DELETE
  UPDATE
}

enum ModeratorAuditSorting {
  # Sort newest to oldest
  NEWEST

  # Sort oldest to newest
  OLDEST
}

type TrashQuery {
  # View your most recently deleted repls
  viewRepls: CluiOutput

  # View your most recently deleted folders
  viewFolders: CluiOutput
}

type TeamQuery {
  # View the members of your team
  view(
    # team name
    team: String!
  ): CluiOutput
}

type ExtensionQuery {
  # View extensions you have created
  view: CluiOutput
}

union CouponQueryOutput = Coupon | UserError

# A subscription coupon
type Coupon {
  id: String!

  # Amount (in dollars) that will be taken off the subtotal of any invoices for this customer.
  amountOff: Int

  # Percent that will be taken off the subtotal of any invoices for this customer for the duration of the coupon. For example, a coupon with percent_off of 50 will make a $100 invoice $50 instead.
  percentOff: Float

  # If duration is repeating, the number of months the coupon applies. Null if coupon duration is forever or once
  months: Int

  # Weather or not the coupon repeats.
  repeating: Boolean!

  # Describes the coupon
  message: String
}

union CustomThemeByIdOutput = NotFoundError | CustomTheme

input CustomThemeByIdInput {
  themeId: Int!
}

union ThemesSearchOutput = UserError | UnauthorizedError | CustomThemeConnection

input ThemesSearchInput {
  after: String
  count: Int
  searchQuery: String
  authorId: Int
  colorScheme: CustomThemeColorScheme
  colorValue: String
}

union AnnotationQueryOutput = AnnotationAnchor | UserError

union ReplCommentOutput = ReplComment | UserError

union GetUserReplCommentsOutput = UnauthorizedError | UserReplCommentsOutput

type UserReplCommentsOutput {
  comments: [ReplComment]!
}

input GetUserReplCommentsInput {
  userId: Int!
}

# A Repl and the connections to it
type ReplConnections {
  # The Repl which users are connected to
  repl: Repl!

  # The users that are connected to the Repl
  users: [User!]!

  # The time when the data was returned
  epoch: DateTime!
}

# A site banner
type Banner {
  id: Int!
  message: String!
}

union GetGoogleClassroomCoursesOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | GoogleClassroomCourseOutput

type GoogleClassroomCourseOutput {
  courses: [GoogleClassroomCourseInfo]!
}

type GoogleClassroomCourseInfo {
  id: String!
  name: String!
}

union GetGoogleClassroomStudentsOutput =
    UserError
  | UnauthorizedError
  | GoogleClassroomStudentOutput

type GoogleClassroomStudentOutput {
  students: [GoogleClassroomStudentInfo]!
}

type GoogleClassroomStudentInfo {
  id: String!
  firstName: String!
  lastName: String!
  email: String!
}

union ReplTemplateOutput = UnauthorizedError | NotFoundError | ReplTemplate

union CurriculumBySlugOutput = UnauthorizedError | NotFoundError | Curriculum

union TemplateReplObject = Repl | ReplTemplate

union TemplateRepls2Output = UserError | TemplateReplSearchConnection

type TemplateReplSearchConnection {
  items: [Repl!]!
  searchQuery: String!
  total: Int!
  orderBy: TemplateRepls2OrderBy!
  promotionStatus: TemplateRepls2PromotionStatus!
  pageInfo: PageInfo!
  category: Int
}

enum TemplateRepls2OrderBy {
  forks
  recent
  searchRelevancy
}

enum TemplateRepls2PromotionStatus {
  all
  promoted
  notPromoted
}

input TemplateRepls2QueryOptions {
  after: Int
  searchQuery: String
  count: Int
  promotionStatus: TemplateRepls2PromotionStatus
  orderBy: TemplateRepls2OrderBy
  category: Int
}

union ExplainCodeOutput = UserError | UnauthorizedError | ExplainCodeResult

type ExplainCodeResult {
  id: String!
  explanation: String!
}

union GenerateCodeOutput = UserError | UnauthorizedError | GenerateCodeResult

type GenerateCodeResult {
  id: String!
  code: String!
  metadata: String!
}

input GenerateCodeInput {
  # The user-provided prompt for the code to generate
  prompt: String!

  # The programming language to generate code in
  language: String!

  # The ID of the Repl in which the code generation is requested. Used for analytics only
  replId: String!
}

union TransformCodeOutput =
    UserError
  | UnauthorizedError
  | ServiceUnavailable
  | TransformCodeResult

type TransformCodeResult {
  id: String!
  code: String!
  metadata: String!
}

input TransformCodeInput {
  # The user-provided prompt for the code to transform
  prompt: String!

  # The code to transform
  input: String!

  # The programming language to transform code in
  language: String!

  # The ID of the repl in which the code generation is requested. Used for analytics only
  replId: String!
}

input ReplPostsQueryOptions {
  after: String
  searchQuery: String
  count: Int
  order: ReplPostsOrder
  boardSlugs: [String!]
  tags: [String!]
}

enum ReplPostsOrder {
  Hot
  New
  Top
}

type TagGroups {
  official(limit: Int, search: String): [Tag!]!
  community(limit: Int, search: String): [Tag!]!
}

union PreviewInvoice =
    UserError
  | NotFoundError
  | UnauthorizedError
  | PreviewInvoiceOutput

type PreviewInvoiceOutput {
  total: Float!
  balance: Float!
  chargeDate: DateTime
  currentItems: [PreviewInvoiceLineItemGroup!]!
  upcomingItems: [PreviewInvoiceLineItemGroup!]!
}

type PreviewInvoiceLineItemGroup {
  periodStart: DateTime!
  periodEnd: DateTime!
  type: String!
  items: [PreviewInvoiceLineItem!]!
}

type PreviewInvoiceLineItem {
  description: String
  amount: Float!
  quantity: Int
}

input PreviewInvoiceInput {
  orgId: Int!
  product: PreviewInvoiceLineItemInput!
}

input PreviewInvoiceLineItemInput {
  # Product ID (only if changing subscribed product)
  id: Int

  # Subscription quantity (only if changing quantity)
  quantity: Int
}

union SearchQueryOutput = UserError | UnauthorizedError | SearchQueryResults

type SearchQueryResults {
  replResults: SearchQueryResultsRepls!
  templateResults: SearchQueryResultsTemplates!
  fileResults: SearchQueryResultsFiles!
  userResults: SearchQueryResultsUsers!
  postResults: SearchQueryResultsPosts!
  docResults: SearchQueryResultsDocs!
  tagResults: SearchQueryResultsTags!
}

type SearchQueryResultsRepls {
  hitInfo: SearchQueryHitInfo!
  results: ReplConnection!
}

# Information about how many hits there were for a search
type SearchQueryHitInfo {
  totalHits: Int!
  totalPages: Int!
}

type SearchQueryResultsTemplates {
  hitInfo: SearchQueryHitInfo!
  results: ReplConnection!
}

type SearchQueryResultsFiles {
  hitInfo: SearchQueryHitInfo!
  results: SearchResultIndexedFileConnection!
}

# A connection to a list of SearchResultIndexedFiles.
type SearchResultIndexedFileConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of SearchResultIndexedFiles.
  items: [SearchResultIndexedFile!]!
}

# An indexed file returned from file search
type SearchResultIndexedFile {
  repl: Repl!
  filePath: String!
  fileContents: String!
  fileContentMatches: [SearchResultIndexedFileMatches!]!
}

# The location of a match in a SearchResultIndexedFile's fileContents
type SearchResultIndexedFileMatches {
  start: Int!
  length: Int!
}

type SearchQueryResultsUsers {
  hitInfo: SearchQueryHitInfo!
  results: UserConnection!
}

type SearchQueryResultsPosts {
  hitInfo: SearchQueryHitInfo!
  results: PostConnection!
}

type SearchQueryResultsDocs {
  hitInfo: SearchQueryHitInfo!
  results: SearchResultIndexedDocConnection!
}

# A connection to a list of SearchResultIndexedDocs.
type SearchResultIndexedDocConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of SearchResultIndexedDocs.
  items: [SearchResultIndexedDoc!]!
}

# An indexed doc returned from doc search
type SearchResultIndexedDoc {
  path: String!
  section: String!
  contents: String!
  contentMatches: [SearchResultIndexedFileMatches!]!
}

type SearchQueryResultsTags {
  hitInfo: SearchQueryHitInfo!
  results: SearchResultTagConnection!
}

# A connection to a list of SearchResultTags.
type SearchResultTagConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of SearchResultTags.
  items: [SearchResultTag!]!
}

# An indexed tag returned from tag search
type SearchResultTag {
  tag: Tag!
  timeLastUsed: DateTime!
  numReplsTotal: Int!
}

input SearchQueryOptions {
  query: String!
  categories: [SearchQueryCategory!]!
  onlyCalculateHits: Boolean
  categorySettings: SearchCategorySettings
}

enum SearchQueryCategory {
  Repls
  Templates
  Files
  Users
  Posts
  Docs
  Tags
}

input SearchCategorySettings {
  repls: SearchQueryReplsSearchSettings
  templates: SearchQueryTemplatesSearchSettings
  files: SearchQueryFilesSearchSettings
  posts: SearchQueryPostsSearchSettings
  users: SearchQueryUsersSearchSettings
  docs: SearchQueryDocsSearchSettings
  tags: SearchQueryTagsSearchSettings
}

input SearchQueryReplsSearchSettings {
  sort: SearchQueryReplSort
  page: SearchQueryPageFilter
  dateCreated: SearchQueryDateFilter
  dateModified: SearchQueryDateFilter
  ownerId: Int
  tags: [String!]
  exactMatch: Boolean
}

enum SearchQueryReplSort {
  Relevant
  Trending
  RecentlyCreated
  RecentlyModified
  MostLikes
  MostRuns
  MostForks
}

# Filter to set the page number (via after) and how many results should be fetched (via first)
input SearchQueryPageFilter {
  after: String
  first: Int
}

input SearchQueryDateFilter {
  gte: DateTime!
}

input SearchQueryTemplatesSearchSettings {
  page: SearchQueryPageFilter
  status: SearchQueryTemplateStatus
  ownerId: Int
  exactMatch: Boolean
}

enum SearchQueryTemplateStatus {
  All
  Official
  Community
}

input SearchQueryFilesSearchSettings {
  sort: SearchQueryFileSort
  page: SearchQueryPageFilter
  fileExtension: String
  exactMatch: Boolean
  myCode: Boolean
}

enum SearchQueryFileSort {
  Relevant
  RecentlyModified
}

input SearchQueryPostsSearchSettings {
  sort: SearchQueryPostSort
  page: SearchQueryPageFilter
  dateCreated: SearchQueryDateFilter
  exactMatch: Boolean
}

enum SearchQueryPostSort {
  Relevant
  RecentlyCreated
  Trending
  MostVotes
  MostComments
}

input SearchQueryUsersSearchSettings {
  page: SearchQueryPageFilter
  exactMatch: Boolean
}

input SearchQueryDocsSearchSettings {
  page: SearchQueryPageFilter
  exactMatch: Boolean
  section: String
}

input SearchQueryTagsSearchSettings {
  page: SearchQueryPageFilter
  exactMatch: Boolean
}

union ThreadsByFileOutput =
    NotFoundError
  | UnauthorizedError
  | ThreadsByFileResult

type ThreadsByFileResult {
  threads: [AnnotationAnchor!]!
}

# A connection to a list of UserEvents.
type UserEventConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of UserEvents.
  items: [UserEvent!]!
}

# User events triggered by current user's followed users.
type UserEvent {
  id: Int!
  eventType: user_eventseventTypeEnumType!
  timeUpdated: Date!
  user: User!
  following: User
  comment: ReplComment
  post: Post
  reaction: ReplReaction
  repl: Repl
}

enum user_eventseventTypeEnumType {
  user_comment
  publish_post
  update_post
  publish_template
  update_template
  create_reaction
  user_following
}

# User events triggered by current user's following users.
type ReplReaction {
  id: Int!
  userId: Int!
  reactionType: repl_reactionsreactionTypeEnumType!
  repl: Repl
}

enum repl_reactionsreactionTypeEnumType {
  heart
  rocket
  eyes
  fire
  open_mouth
}

union TutorialReplsOutput = UnauthorizedError | TutorialReplsResults

type TutorialReplsResults {
  results: [Repl!]!
}

input TutorialReplsInput {
  category: TutorialReplsCategory!
}

enum TutorialReplsCategory {
  all
  codealong
  highlighted
  remix
}

union InstantGitHubImportOutput =
    NotFoundError
  | UserError
  | InstantGitHubImportResult

type InstantGitHubImportResult {
  language: String!
  templateId: String!
  isPrivate: Boolean!
}

input InstantGitHubImportInput {
  username: String!
  repository: String!
}

union ModeratorAuditLogOutput = UnauthorizedError | ModeratorAuditLogConnection

# A connection to a list of ModeratorAuditLogs.
type ModeratorAuditLogConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of ModeratorAuditLogs.
  items: [ModeratorAuditLog!]!
}

# A moderator audit log entry.
type ModeratorAuditLog {
  id: Int!
  model: moderator_action_recordmodelEnumType!
  type: moderator_action_recordtypeEnumType!
  updateBody: String
  moderator: User
  post: Post
  comment: ReplComment
  bannedUser: User
  boardReport: BoardReport
  warnedUser: User
  repl: Repl
  notification: BasicNotification
  bountyApplication: BountyApplication
  customTheme: CustomTheme
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

enum moderator_action_recordmodelEnumType {
  Boards
  Posts
  Comments
  BannedBoardUsers
  BoardReports
  Warning
  Repls
  Notifications
  BountyApplications
  CustomThemes
}

enum moderator_action_recordtypeEnumType {
  create
  update
  delete
}

# Additional options for pagination and filtering audit log
input ModeratorAuditLogInputType {
  after: Int
  limit: Int
  moderator: Int
  model: ModeratorAuditLogModel
  type: ModeratorAuditLogType
  targetId: Int
  replId: String
  order: ModeratorAuditLogOrder
}

enum ModeratorAuditLogModel {
  boards
  posts
  comments
  bannedBoardUsers
  boardReports
  warning
  repls
  notifications
  bountyApplications
  customThemes
}

enum ModeratorAuditLogType {
  create
  update
  delete
}

enum ModeratorAuditLogOrder {
  newest
  oldest
}

union ImageScansOutput = UserError | UnauthorizedError | ImageScanConnection

# A connection to a list of ImageScans.
type ImageScanConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of ImageScans.
  items: [ImageScan!]!
}

type ImageScan {
  # Image scan classification ID
  id: Int!

  # ID of the image that corresponds to the scan
  image_id: Int!

  # Context in which the image was uploaded
  upload_context: String!

  # URL to the image
  image_url: String!

  # User who uploaded the image
  creator: User!

  # Score associated to the image by the scanning model
  score: Float!

  # When the image was uploaded
  time_image_uploaded: DateTime

  # When the image scan was completed
  time_scan_results_obtained: DateTime

  # Whether the image scan has been resolved
  resolved: Boolean!
}

# Teacher verification information
type TeacherVerification {
  userId: Int!
  formResponses: SequelizeJSON!

  # email of the user that submitted the verification request
  email: String!

  # username of the user that submitted the verification request
  username: String!
}

# The `JSON` scalar type represents raw JSON as values.
scalar SequelizeJSON

union CourseLessonsReplsOutput = NotFoundError | CourseLessonsRepls

type CourseLessonsRepls {
  # A list of lesson identifier / repl pairs
  results: [LessonRepl!]!
}

# A lesson / repl pair
type LessonRepl {
  lessonSlug: String!
  repl: Repl!
}

union BountyByIdOutput = NotFoundError | UnauthorizedError | Bounty

input BountyByIdInput {
  id: Int!
}

union BountySearchOutput =
    UserError
  | UnauthorizedError
  | BountySearchConnection

# A connection to a list of Bounties
type BountySearchConnection {
  items: [Bounty!]!
  pageInfo: PageInfo!
}

input BountySearchInput {
  # Controls which page of results to fetch
  after: String

  # How many Bounties to fetch in this page of results
  count: Int

  # The query to use to filter results
  searchQuery: String

  # The ID of a Bounty Hunter to use to filter results
  hunterId: Int

  # The ID of a Bounty Poster to use to filter results
  posterId: Int

  # Use statuses filter instead
  status: BountySearchStatusFilter

  # The statuses to include when searching for Bounties, if none are specified, this will include Bounties with any status
  statuses: [BountySearchStatus!]

  # The order to use when sorting the results
  order: BountySearchOrder

  # Filters applied to the Bounty's reward
  cycles: BountySearchInputCyclesFilter

  # Filters applied to the Bounty's time created
  timeCreated: BountySearchInputTimeCreatedFilter

  # Filters applied based on Bounty's listing state
  listingState: BountySearchListingStateFilter
}

enum BountySearchStatusFilter {
  all
  inProgress
  open
  canceled
  completed
}

enum BountySearchStatus {
  inProgress
  open
  canceled
  completed
}

enum BountySearchOrder {
  # The default recommended sort
  recommended

  # Sort Bounties with the lowest applications to the top
  applicationCountAscending

  # Sort Bounties with the highest reward to the top
  cyclesDescending

  # Sort Bounties created most recently to the top
  creationDateDescending

  # Sort Bounties updated most recently to the top
  lastUpdatedDateDescending
}

input BountySearchInputCyclesFilter {
  # Filters Bounties to those with cycles greater than or equal to this amount
  gte: Int!
}

input BountySearchInputTimeCreatedFilter {
  # Filters Bounties to those created at or after this date time
  lte: DateTime!
}

enum BountySearchListingStateFilter {
  all
  unlisted
  listed
}

union GetRecommendedBountiesForUserOutput =
    UserError
  | TooManyRequestsError
  | UnauthorizedError
  | GetRecommendedBountiesForUserResult

# An error caused by a user making too many requests
type TooManyRequestsError {
  message: String!
}

type GetRecommendedBountiesForUserResult {
  # List of recommended Bounties
  results: [Bounty!]!
}

input GetRecommendedBountiesForUserInput {
  # How many recommended Bounties to attempt to find
  count: Int
}

union BountyApplicationByIdOutput =
    NotFoundError
  | UnauthorizedError
  | BountyApplication

input BountyApplicationByIdInput {
  id: Int!
}

union BountyApplicationSearchOutput = UserError | BountyApplicationConnection

# A connection to a list of BountyApplications.
type BountyApplicationConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of BountyApplications.
  items: [BountyApplication!]!
}

input BountyApplicationSearchInput {
  bountyId: Int
  after: String
  count: Int
  order: BountyApplicationSearchOrder
  status: BountyApplicationSearchStatus
}

enum BountyApplicationSearchOrder {
  recommended
  completedBountiesDescending
  applicationDateDescending
  applicationDateAscending
}

enum BountyApplicationSearchStatus {
  all
  accepted
  notReviewed
  rejected
  rejectedAndNotReviewed
  awaitingModeration
}

union BountyChatSearchOutput =
    UnauthorizedError
  | TooManyRequestsError
  | UserError
  | NotFoundError
  | BountyChatMessageConnection

# A connection to a list of BountyChatMessages.
type BountyChatMessageConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of BountyChatMessages.
  items: [BountyChatMessage!]!
}

input BountyChatSearchInput {
  bountyApplicationId: Int!

  # provide this param to load newer messages in history.
  after: String

  # provide this param to load older messages in history.
  before: String
  count: Int
}

union BountyHunterServiceSearchOutput =
    UserError
  | TooManyRequestsError
  | UnauthorizedError
  | BountyHunterServiceConnection

# A connection to a list of BountyHunterServices.
type BountyHunterServiceConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of BountyHunterServices.
  items: [BountyHunterService!]!
}

# A service that is offered by a Bounty Hunter
type BountyHunterService {
  id: Int!
  title: String!
  description: String!

  # Cycles that it costs to buy this service
  cycles: Int!

  # Cover image for this service
  imageUrl: String!

  # Time to complete this service in seconds
  timeToComplete: Int!

  # Whether or not this service is available to be purchased currently
  isAvailable: Boolean!

  # Whether or not this service is publicly listed
  isUnlisted: Boolean!

  # User who is providing this service
  user: User
}

input BountyHunterServiceSearchInput {
  # Unused, but setting API up for pagination
  after: String

  # Unused, but setting API up for pagination
  count: Int
}

union BountyHunterServiceByIdOutput =
    NotFoundError
  | UnauthorizedError
  | UserError
  | BountyHunterService

input BountyHunterServiceByIdInput {
  id: Int!
}

union BountyByUrlOutput = NotFoundError | UnauthorizedError | Bounty

input BountyByUrlInput {
  slug: String!
  username: String!
}

union TemplateCategoriesOutput = UserError | TemplateCategoriesResults

type TemplateCategoriesResults {
  # A list of template categories.
  results: [TemplateCategory!]!
}

input TemplateCategoriesInput {
  # Only return set list of template categories by their ids in order improve test reliability.
  ids: [Int!]!
}

union TemplateCategoryBySlugOutput =
    UserError
  | NotFoundError
  | TemplateCategory

input TemplateCategoryBySlugInput {
  # unique slug associated with a template category
  slug: String!
}

# An object with upload and download URLs for support assets
type SupportAssetUrls {
  uploadUrl: String!
  downloadUrl: String!
  contentType: String!
}

type Extension {
  id: String!
  name: String!
  description: String!
  url: String
  isBlessed: Boolean!
  timeCreated: Date!
  timeUpdated: Date
  user: User!
  installation(replId: String): ExtensionInstallation
  manifest: ExtensionManifestResult
  installCount: String!
}

type ExtensionInstallation {
  id: String!
  timeCreated: Date!
  timeUpdated: Date

  # The repl to which the extension is installed
  repl: Repl
  extension: Extension

  # The user to whom the extension is installed
  user: User

  # The user who installed the extension
  installer: User

  # A signed JWT that an extension can use to authenticate a user
  token: String
}

union ExtensionManifestResult = ExtensionManifest | ExtensionManifestError

type ExtensionManifest {
  name: String!
  description: String!
  version: String!
  scopes: [ExtensionScope!]
  icon: String
  tags: [String!]
  supportEmail: String
  website: String
  longDescription: String
  coverImages: [ExtensionCoverImage!]
  fileHandlers: [ExtensionFileHandler!]
  tools: [ExtensionTool!]
}

type ExtensionScope {
  name: String!
  reason: String!
}

type ExtensionCoverImage {
  url: String!
  path: String!
  label: String!
}

type ExtensionFileHandler {
  glob: String!
  handler: String!
  name: String
  icon: String
}

type ExtensionTool {
  handler: String!
  name: String
  icon: String
}

type ExtensionManifestError {
  message: String!
}

union TemplateReplBySlugOutput = UserError | NotFoundError | Repl

input TemplateReplBySlugInput {
  # unique slug for the template landing page
  slug: String!
}

union GetBannedBoardUserOutput =
    NotFoundError
  | UnauthorizedError
  | BannedBoardUser

# Users who are banned from social boards
type BannedBoardUser {
  id: Int!
  reason: String!
  timeExpired: Date
  timeCreated: Date!
  isActive: Boolean!
  user: User
  creator: User
}

union StudentsSubmissionsOutput =
    UnauthorizedError
  | UserError
  | StudentsSubmissionsResults

type StudentsSubmissionsResults {
  # A list of student submissions, preserving the order from input.studentIds
  results: [StudentSubmissions!]!
}

type StudentSubmissions {
  userId: Int!
  templateSubmissions: [TemplateSubmission!]!
}

type TemplateSubmission {
  templateId: Int!
  submission: ReplSubmission!
}

# Given sets of student and template IDs, return a list of student submisssions
input StudentsSubmissionsInput {
  teamId: Int!

  # Student User IDs for which we want submissions
  studentIds: [Int!]!

  # Template IDs for which we want submissions
  templateIds: [Int!]!
}

union ReplBootStatusHistoryOutput =
    UnauthorizedError
  | UserError
  | ReplBootStatusHistoryConnection

type ReplBootStatusHistoryConnection {
  # A list of repl status history events
  items: [ReplBootStatusEvent!]!
  pageInfo: PageInfo!
}

# A repl status event.
type ReplBootStatusEvent {
  status: ReplBootStatusValue!
  timestamp: DateTime!
}

enum ReplBootStatusValue {
  awake
  asleep
  alwaysOn
  limited
}

input ReplBootStatusHistoryInput {
  replId: String!
  after: String
  count: Int
}

union ReplBootStatusOutput =
    UnauthorizedError
  | UserError
  | ReplBootStatusConnection

type ReplBootStatusConnection {
  # A list of repl status
  items: [ReplBootStatus!]!
  pageInfo: PageInfo!
}

# A repl status.
type ReplBootStatus {
  repl: Repl!
  status: ReplBootStatusValue!
  timestamp: DateTime!
}

input ReplBootStatusInput {
  after: String
  count: Int
  sort: ReplBootStatusSort
}

enum ReplBootStatusSort {
  statusDescending
  latestActivity
}

union TipaltiIframeUrl = UserError | UnauthorizedError | TipaltiIframeUrlResult

type TipaltiIframeUrlResult {
  iframeUrl: String!
}

union GetNeonDatabasesOutput =
    UserError
  | UnauthorizedError
  | GetNeonDatabasesResult

type GetNeonDatabasesResult {
  databases: [NeonDatabase!]!
}

type NeonDatabase {
  projectId: String!
  databaseId: Int!
  databaseName: String!
  connectionString: String!
  isFrozen: Boolean!
}

input GetNeonDatabasesInput {
  replId: String!
}

union TopGlobalTippersOutput = UserError | LeaderboardTopTippersResult

# A leaderboard of users who have received the most tips
type LeaderboardTopTippersResult {
  leaderboard: [TipperUser!]!
}

union ReplContinents = UnauthorizedError | ReplContinentsOutput

type ReplContinentsOutput {
  continents: [ReplContinent!]!
}

union AllowedReplIdentityRepls =
    UnauthorizedError
  | AllowedReplIdentityReplsOutput

type AllowedReplIdentityReplsOutput {
  repls: [Repl!]!
}

union InvoiceOutput = UnauthorizedError | NotFoundError | Invoice

type Invoice {
  id: String!
  title: String!
  description: String
  amount: Int!
  redirectUrl: String

  # The status of the invoice
  status: InvoiceStatus!

  # The user who issued the invoice.  Null if the user was deleted.
  issuer: User

  # The user the invoice was issued to.  Null if the user was deleted.
  recipient: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

enum InvoiceStatus {
  # The invoice is pending approval.
  PENDING

  # The charge has been approved but needs to be confirmed by the application.
  APPROVED

  # The invoice has been confirmed and cycles have been issued.
  COMPLETED

  # The transaction was cancelled by the application.
  CANCELLED

  # The transaction was denied by the user.
  DENIED
}

union ExtensionOutput = NotFoundError | Extension

union ExtensionInstallationByIdOutput = NotFoundError | ExtensionInstallation

union ExtensionInstallationsOutput =
    NotFoundError
  | UnauthorizedError
  | ExtensionInstallationList

type ExtensionInstallationList {
  installations: [ExtensionInstallation!]!
}

union PreviewProrationOutput =
    PaymentError
  | UserError
  | UnauthorizedError
  | PreviewProrationResult

# An error of Payment Processor origin
type PaymentError {
  message: String!
}

type PreviewProrationResult {
  # The total amount of the proration in cents
  prorationTotalInCents: Int!

  # Whether the invoice preview is for a change from a free trial to a paid subscription
  isTrialToPaid: Boolean!
}

input PreviewProrationInput {
  # The plan prefix of the subscription type to change the users current subscription to
  newPlanPrefix: SelectableSubscriptionPrefixTypesEnum!

  # The plan period of the subscription type to change the users current subscription to
  newPlanPeriod: SelectableSubscriptionPeriodTypesEnum!
}

enum SelectableSubscriptionPrefixTypesEnum {
  hacker
  hacker_pro
}

enum SelectableSubscriptionPeriodTypesEnum {
  monthly
  yearly
}

type SubscriptionPlansOutput {
  free: FreePlan!
  hacker: SubscriptionPlan!
  pro: SubscriptionPlan!
}

type FreePlan {
  displayName: String!
  items: [SubscriptionPlanItem!]!
}

type SubscriptionPlanItem {
  code: SubscriptionPlanItemEnumType!
  description: String!
  details: String
  pillText: String
  learnMoreLink: String
  showOnMobile: Boolean!
}

enum SubscriptionPlanItemEnumType {
  privateRepls
  accountStorage
  dataTransfer
  workspaceSpeed
  alwaysOnRepl
  boostedRepl
  sshCapability
  ghostwriter
}

type SubscriptionPlan {
  displayName: String!
  apple: ProviderPlanDetails!
  google: ProviderPlanDetails!
  stripe: StripeProviderPlanDetails!
  items: [SubscriptionPlanItem!]!
}

type ProviderPlanDetails {
  monthlyPlanDetails: PlanDetails!
  yearlyPlanDetails: PlanDetails!
}

type PlanDetails {
  planId: String!
  googleSubscriptionId: String
  costInUsdCents: Int!
}

type StripeProviderPlanDetails {
  monthlyPlanDetails: StripePlanDetails!
  yearlyPlanDetails: StripePlanDetails!
}

type StripePlanDetails {
  costInUsdCents: Int!
}

union HostingBuildDeployActionHistoryOutput =
    UnauthorizedError
  | NotFoundError
  | HostingBuildDeployActionHistoryResults

# Hosting build deploy action history
type HostingBuildDeployActionHistoryResults {
  results: [HostingBuildDeployActionUpdateEvent!]
}

# A hosting deploy action update event
union HostingBuildDeployActionUpdateEvent =
    HostingBuildDeployLogAction
  | HostingBuildDeployStatusAction

type HostingBuildDeployLogAction {
  log: String!
}

type HostingBuildDeployStatusAction {
  status: HostingBuildStatus!
  message: String
}

input HostingBuildDeployActionHistoryInput {
  buildId: String!
}

union AvailableReplTitleOutput = UnauthorizedError | AvailableReplTitleResult

type AvailableReplTitleResult {
  isAvailable: Boolean!
}

input AvailableReplTitleInput {
  # The Repl title to check availability of
  title: String!

  # The team id if checking for the availability of a team Repl title
  teamId: Int
}

union GetReplitCheckoutSessionOutput =
    NotFoundError
  | UnauthorizedError
  | ReplitCheckoutSession

# A Replit checkout session. Basically a wrapper around a Stripe Payment Intent and provisioning of Replit products.
type ReplitCheckoutSession {
  id: String!
  status: CheckoutSessionStatus!
}

# The status of a Replit Checkout Session
enum CheckoutSessionStatus {
  # The checkout session has been started
  started

  # The checkout session is provisioning cycles
  provisioning_cycles

  # The checkout session is provisioning a product
  provisioning_product

  # Payment for the checkout session has failed (terminal)
  payment_failed

  # The checkout session has succeeded and has been successfully provisioned (terminal)
  succeeded

  # The checkout session has succeeded but provisioning of cycles has failed (terminal)
  cycles_provisioning_failed

  # The checkout session has succeeded but provisioning of the product has failed (terminal)
  product_provisioning_failed
}

input GetReplitCheckoutSessionInput {
  # Checkout session ID
  id: String!
}

union ReplitAppSubdomainAvailabilityOutput =
    UserError
  | ReplitAppSubdomainAvailabilityResult

type ReplitAppSubdomainAvailabilityResult {
  # Whether the subdomain is available for use
  available: Boolean!

  # Additional context about the availability
  message: String
}

union AnonymousFlagOutput = UserError | Flag

input AnonymousFlagInput {
  id: String!
  type: UserFlagValueType!
  default: FlagValueType

  # The anonymous ID (user key) to use to flag the user. It's optional: if you don't provide one, the normal gating ID will be used.
  userKey: String
}

# The top level entry point for mutating the graph
type RootMutationType {
  # Marks a tour as seen
  toursSeen(name: String!): ToursSeenMuationResult!

  # Marks a tour as seen
  markTourAsSeen(name: String!): TourSeen!

  # Updates a Repl
  updateRepl(input: UpdateReplInput!): UpdateReplPayload!

  # Deletes a repl
  deleteRepl(id: String!): Repl!

  # Updates time_updated of a repl
  updateReplTimeUpdated(id: String!): UpdateReplTimeUpdatedOutput!

  # Updates a Post
  updatePost(input: UpdatePostInput!): UpdatePostPayload!
  pinReplToProfile2(replId: String!): PinReplToProfileOutput!
  unpinReplFromProfile2(replId: String!): UnpinReplFromProfileOutput!
  createBoardReport(
    postId: Int
    commentId: Int
    replId: String
    reason: String!
    reportedUserId: Int
  ): BoardReport!
  reportReplComment(
    replCommentId: Int!
    reason: String!
  ): ReportReplCommentOutput!
  reportBounty(bountyId: Int!, reason: String!): ReportBountyOutput!
  reportBountyApplication(
    bountyApplicationId: Int!
    reason: String!
  ): ReportBountyApplicationOutput!
  resolveBoardReport(id: Int!): BoardReport!
  unresolveBoardReport(id: Int!): BoardReport!
  createReplFolder(name: String!, parentId: String, teamId: Int): ReplFolder!
  deleteReplFolder(folderId: String!): ReplFolder!
  updateReplFolder(folderId: String!, name: String!): ReplFolder!
  moveItemsToFolder(
    replIds: [String]!
    folderIds: [String]!
    destFolderId: String!
    teamId: Int
  ): [DashboardItem!]!
  addMultiplayerUser(
    username: String!
    replId: String!
    type: String!
  ): ReplPermission!
  removeMultiplayerUser(username: String!, replId: String!): ReplPermission!

  # Marks all notifications as seen
  markAllNotificationsAsSeen: CurrentUser!

  # Marks all notifications of a certain type as seen
  markNotificationsAsSeen(
    context: NotificationContext
    url: String
    id: Int
    ids: [Int]
  ): Int!

  # Refreshes a multiplayer invite link
  refreshMultiplayerInviteLink(replId: String!): Repl!
  createMultiplayerInvite2(
    email: String!
    replId: String!
    type: String!
  ): MultiplayerInviteOutput!
  deleteMultiplayerInvite(
    email: String!
    replId: String!
  ): MultiplayerInviteOutput!
  updateBoardTrendingAlgorithmSettings(
    input: UpdateBoardTrendingAlgorithmSettingsInput!
  ): BoardTrendingAlgorithmSettings!

  # Updates the current user's email if allowed
  updateEmail(email: String!, password: String!): UpdateUserOutput

  # Unshares a shared repl with the current user
  removeSharedRepl(replId: String!): Repl!
  createRepl(
    input: CreateReplInput!
    isTitleAutoGenerated: Boolean
  ): CreateReplOutput!
  updateCurrentUser(input: UpdateCurrentUserInput!): CurrentUser

  # Updates the current user's password if allowed
  updatePassword(
    currentPassword: String!
    newPassword: String!
  ): UpdateUserOutput

  # Updates the current user's continent if allowed
  selectReplContinent(input: SelectReplContinentInput!): SelectReplContinent!

  # Updates the current user's email if allowed
  updateRole(role: UserRoles!, flag: Boolean!): UpdateUserOutput

  # ClUI root command
  clui: CluiMutation

  # Link a custom domain name to a repl
  linkReplDomain2(
    replId: String!
    domain: String!
    deploymentId: String
  ): LinkReplDomain2!
  createAnnotationAnchor(
    annotationAnchor: AnnotationAnchorInput!
    annotationMessage: AnnotationMessageInput
    highlight: AnnotationHighlightInput
  ): CreateAnnotationAnchorOutput
  createAnnotationMessage(
    replId: String!
    anchorId: String!
    annotationMessage: AnnotationMessageInput!
    highlight: AnnotationHighlightInput
  ): CreateAnnotationMessageOutput
  updateAnnotationAnchor(
    id: String!
    changes: AnnotationAnchorChangesInput!
  ): UpdateAnnotationAnchorOutput
  deleteTeam(input: DeleteTeamInput!): TeamOutput!
  updateTeam(input: UpdateTeamInput!): TeamOutput!
  removeTeamMember(input: RemoveTeamMemberInput!): RemoveTeamMemberOutput!
  leaveTeam(teamId: Int!): LeaveTeamOutput!
  createTeamInvite(input: CreateTeamInviteInput!): CreateTeamInviteOutput!
  deleteTeamInvite(input: DeleteTeamInviteInput!): DeleteTeamInviteOutput!

  # Creates a test event for graphql subscriptions
  testSubscription: Boolean
  createTeamInviteLink(teamId: Int!): CreateTeamInviteLinkOutput!
  deleteTeamInviteLink(teamId: Int!): DeleteTeamInviteLinkOutput!
  updateTeamUserPermissions(
    input: UpdateTeamUserPermissionsInput!
  ): UpdateTeamUserPermissionsOutput!
  createReplTemplate(input: CreateReplTemplateInput!): CreateReplTemplateOutput!
  createReplAsTemplate(
    input: CreateReplAsTemplateInput!
  ): CreateReplAsTemplateOutput!
  updateReplTemplate(
    input: UpdateReplTemplateInput!
  ): UpdateReplTemplateOutputType!

  # ...
  submitRepl(replId: String!): SubmitReplOutput!

  # Lets a teacher unsubmit a Repl submission
  unsubmitRepl(replId: String!): UnsubmitReplOutput!

  # Mark a submission reviewed
  reviewRepl(replId: String!, status: Boolean!): ReviewReplOutput!

  # The mutation used to fork a project.
  createReplSubmission(templateId: Int!): CreateReplSubmissionOutput!
  updateTeamInviteLinkEduSignup(
    teamId: Int!
    enabled: Boolean!
  ): UpdateTeamInviteLinkEduSignupOutput!
  createTemplateTest(input: CreateTemplateTestInput!): TemplateTestOutput!
  createReplUnitTest(input: CreateReplUnitTestInput!): ReplUnitTestOutput!
  deleteReplUnitTest(testId: Int!): ReplUnitTestOutput!
  updateReplUnitTest(input: UpdateReplUnitTestInput!): ReplUnitTestOutput!
  createReplUnitTestMeta(
    input: CreateReplUnitTestMetaInput!
  ): ReplUnitTestMetaOutput!
  updateReplUnitTestMeta(
    input: UpdateReplUnitTestMetaInput!
  ): ReplUnitTestMetaOutput!
  updateReplUnitTestLastRun(
    input: UpdateReplUnitTestLastRunInput!
  ): UpdateReplUnitTestLastRunOutput

  # Creates goval connection metadata with limited capabilities. Notably no network access and reduced CPU and memory.
  createLanguageConnectionMetadata(
    language: String!
    overrideClusterMetadata: ClusterMetadata
  ): CreateLanguageConnectionMetadataOutput!
  deleteTemplateTest(testId: Int!): DeleteReplTemplateOutput!
  updateTemplateTest(input: UpdateTemplateTestInput!): TemplateTestOutput!
  updateEditorPreferences(input: UpdateEditorPreferencesInput!): CurrentUser!
  createReplComment(input: CreateReplCommentInput!): CreateReplCommentOutput!
  setReplCommentSettings(input: SetReplCommentSettingsInput!): ReplOutput!
  createReplCommentReply(
    input: CreateReplCommentReplyInput!
  ): CreateReplCommentReplyOutput!
  ownAnonRepl(input: OwnAnonReplInput!): ReplOutput!
  updateReplComment(input: UpdateReplCommentInput!): ReplCommentOutput!
  deleteReplComment(id: Int!): ReplCommentOutput!
  createTeamInvitesFromCSV(input: CSVFileInput!): TeamOutput!
  createTemplateShareLink(teamId: Int!, templateIds: [Int!]!): Team!
  resetPrivacyStudentPassword(
    teamId: Int!
    userId: Int!
    password: String!
  ): ResetPrivacyStudentPasswordOutput!

  # The mutation used to get the templates from another team via the code of a template share link
  useTemplateShareLink(
    # The id of the team which the templates should be copied to
    teamId: Int!

    # The code of the link which we should copy templates from
    code: String!

    # The templates which should be taken from the link
    content: [Int!]!

    # Whether the timestamps for the templates should be copied or not
    withDates: Boolean!
  ): Int!

  # The mutation used to update a template share link for a team
  updateTemplateShareLink(
    # The id of the team which the link belongs to
    teamId: Int!

    # The id of the link which is to be updated.
    linkId: Int!
    templateIds: [Int!]!
  ): TeamTemplateShareLink!

  # The mutation used to delete a team's template share link
  deleteTemplateShareLink(
    # The id of the team which the link belongs to
    teamId: Int!

    # The id of the link which should be deleted
    linkId: Int!
  ): Team
  deleteProjectAndSubmissions(id: Int!): DeletedProjectAndSubmissionOutput!
  disconnectAuthProvider(provider: UserAuthProviders!): CurrentUser!
  setAlwaysOn(replId: ID!, enabled: Boolean!): SetAlwaysOnOutput!
  createReplRelease(input: CreateReplReleaseInput!): CreateReplReleaseOutput!
  revertReplRelease(input: RevertReplReleaseInput!): RevertReplReleaseOutput!

  # Creates a deployment and release
  createReplDeployment(
    input: CreateReplDeployemntInput!
  ): CreateReplDeployemntOutput!
  deleteReplDeployment(
    input: DeleteReplDeploymentInput!
  ): DeleteReplDeploymentOutput!

  # Marks all messages in thread as read
  markMessagesAsSeen(
    replId: String!
    threadId: String
    messageIds: [String!]
  ): MarkMessagesAsSeenOutput

  # Deletes a user's account
  deleteAccount: Boolean!
  createReplRun(replId: String!): CreateReplRunOutput!

  # Change conversation message preview in response to user input
  updateThreadPreview(
    threadId: String!
    messageId: String!
    message: String
  ): Boolean
  updateTeamOrganization(
    input: UpdateTeamOrganizationInput!
  ): UpdateTeamOrganizationOutput!
  saveIOTestResults(
    # The ID of the team which the Repl the results are for belongs to.
    teamId: Int!

    # The ID of the Repl which the test results are for.
    replId: String!

    # The results of the I/O tests executed on the Repl.
    results: [IOTestResultInput!]!
  ): SaveIOTestResultOutput

  # Updates a team member's nickname
  updateTeamMember(input: UpdateTeamMemberInput!): UpdateTeamMemberOutput!

  # Adds a new team to the organization, or adds a new free team if not associated with org.
  createTeamV2(input: CreateTeamV2Input!): CreateTeamV2Output!
  connectGoogleClassroom(
    input: ConnectGoogleClassroomInput!
  ): ConnectGoogleClassroomOutput
  deleteMultiplayerInviteLink(replId: String!): DeleteMultiplayerInviteLink!
  exportTeamSubmissions(teamId: Int!): ExportTeamSubmissionsOutput!
  disconnectGoogleClassroom(
    input: DisconnectGoogleClassroomInput!
  ): DisconnectGoogleClassroomOutput!

  # Creates a group project submission
  createReplSubmissionGroup(
    input: CreateReplSubmissionGroupInput!
  ): CreateReplSubmissionGroupOutput!

  # Creates a group project submission
  joinReplSubmissionGroup(
    input: JoinReplSubmissionGroupInput!
  ): JoinReplSubmissionGroupOutput
  exportProjectsOverview(
    input: ExportProjectsOverviewInput!
  ): ExportProjectsOverviewOutput!
  archiveTeam(input: ArchiveTeamInput!): ArchviveTeamInput!
  unarchiveTeam(input: UnarchiveTeamInput!): UnarchiveTeamOutput!
  setLanguageTemplateRepl(
    input: SetLanguageTemplateInput!
  ): SetLanguageTemplateOutput!
  setBetaTemplateRepl(input: SetBetaTemplateInput!): SetBetaTemplateOutput
  createStack(input: CreateStackInput!): CreateStackOutput
  arrangeStackItem(input: ArrangeStackItemInput!): ArrangeStackItemOutput
  uploadReplAttachment(
    input: UploadReplAttachmentInput!
  ): UploadReplAttachmentOutput
  importCurriculum(input: ImportCurriculumInput!): ImportCurriculumOutput!

  # Migrates team from old hacky collections to stacks
  migrateTeamToStacks(teamId: Int!): MigrateTeamToStacksOutput
  updateStack(input: UpdateStackInput!): UpdateStackOutput!
  deleteStack(stackId: Int!): DeleteStackOutput!
  arrangeStack(input: ArrangeStackInput!): ArrangeStackOutput!
  createReplPost2(input: CreateReplPost2Input!): CreateReplPost2Output!
  unpublishReplFromCommunity(
    input: UnpublishReplFromCommunityInput!
  ): UnpublishReplFromCommunityOutput!
  giveCodexFeedback2(input: CodexFeedback2Input!): CodexFeedback2Output!
  toggleReplLike(input: ToggleReplLikeInput!): ToggleReplLikeOutput!
  setFollowing(input: setFollowingInput!): setFollowing
  setBlocking2(input: SetBlocking2Input!): SetBlocking2!
  setTemplateReplCategory(
    input: SetTemplateReplCategoryInput!
  ): SetTemplateCategoryOutput!
  setOnboardingExperience(
    role: OnboardingExperience!
  ): SetOnboardingExperienceOutput!
  setOnboardingIntent(role: Intent!): SetOnboardingIntentOutput!

  # Creates a model solution for a project
  createReplTemplateModelSolution(
    input: CreateReplTemplateModelSolutionInput!
  ): CreateReplTemplateModelSolutionOutput!

  # Creates a model solution fork for students to view and edit
  createReplTemplateModelSolutionFork(
    input: CreateReplTemplateModelSolutionForkInput!
  ): CreateReplTemplateModelSolutionForkOutput!

  # Creates a model solution for a project
  updateReplTemplateModelSolution(
    input: UpdateReplTemplateModelSolutionInput!
  ): UpdateReplTemplateModelSolutionOutput!
  updateTeamOrganizationMember(
    input: UpdateTeamOrganizationMemberInput!
  ): UpdateTeamOrganizationMemberOutput!
  deleteTeamOrganizationMember(
    input: DeleteTeamOrganizationMemberInput!
  ): DeleteTeamOrganizationMemberOutput!
  deleteTeamOrganization(
    input: DeleteTeamOrganizationInput!
  ): DeleteTeamOrganizationOutput!
  createTeamOrganizationInvite(
    input: CreateTeamOrgInviteInput!
  ): CreateTeamOrgInviteOutput!
  deleteTeamOrganizationInvite(
    input: DeleteTeamOrgInviteInput!
  ): DeleteTeamOrgInviteOutput!
  updateSubscription(input: UpdateSubscriptionInput!): UpdateSubscription!
  createTeamOrgInviteLink(orgId: Int!): CreateTeamOrgInviteLinkOutput!
  deleteTeamOrgInviteLink(orgId: Int!): DeleteTeamOrgInviteLinkOutput!
  copyTeamTemplate(input: CopyTeamTemplateInput!): CopyTeamTemplateOutput!
  copyStacksToTeam(input: CopyStacksToTeamInput!): CopyStacksToTeamOutput!
  joinTeamAsOrgAdmin(teamId: Int!): JoinTeamAsOrgAdminOutput!
  setUserSocials(input: SetUserSocialsInput!): SetUserSocialsOutput!
  updateUserSitePresence: UpdateUserSitePresenceOutput!
  updateUserPrivacyPreferences(
    input: UpdateUserPrivacyPreferencesInput!
  ): UpdateUserPrivacyPreferencesOutput!
  setUserCoverImage(input: SetUserCoverImageInput!): SetUserCoverImageOutput!
  createTheme(input: CreateThemeInput!): CreateThemeOutput!
  updateTheme(input: UpdateThemeInput!): UpdateThemeOutput!
  publishTheme(input: PublishThemeInput!): PublishThemeOutput!
  unpublishTheme(input: UnpublishThemeInput!): UnpublishThemeOutput!
  unpublishThemeAsModerator(
    input: UnpublishThemeAsModeratorInput!
  ): UnpublishThemeAsModeratorOutput!
  installTheme(input: InstallThemeInput!): InstallThemeOutput!
  uninstallTheme(input: UninstallThemeInput!): UninstallThemeOutput!
  deleteTheme(input: DeleteThemeInput!): DeleteThemeOutput!
  upgradeTheme(input: UpgradeThemeInput!): UpgradeThemeOutput!
  setActiveTheme(input: SetActiveThemeInput!): SetActiveThemeOutput
  reportCustomTheme(
    customThemeId: Int!
    customThemeVersionId: Int!
    reason: String!
  ): ReportCustomThemeOutput!
  toggleHiddenComment(
    commentId: Int!
    isHidden: Boolean!
  ): ToggleHiddenCommentOutput!
  toggleHiddenPost(postId: Int!, isHidden: Boolean!): ToggleHiddenPostOutput!
  importGithubRepo(input: ImportGithubRepoInput!): ImportGithubRepoOutput!

  # Creates an access token for client GitHub interactions. The token lasts for 1hr after which using it will result in a 401. If the token is still needed, this mutation must be called again to create another.
  createGithubAccessToken(
    input: CreateGithubAccessTokenInput!
  ): CreateGithubAccessTokenOutput!

  # Warn a user
  warnUser(username: String!, reason: String!): WarnUserOutput!

  # Remove a warning from a user
  removeWarn(username: String!, warnId: Int!): RemoveWarnOutput!

  # Ban a user from community.
  banCommunityUser(
    username: String!
    reason: String!
    timeExpired: DateTime
  ): BanCommunityUserOutput!
  setReplLayoutState(input: SetReplLayoutStateInput!): SetReplLayoutStateOutput!
  setReplTags(input: SetReplTagsInput!): SetReplTagsOutput!
  setReplExamples(input: SetReplExamplesInput!): SetReplExamplesOutput!
  createNewTeamsEduOrganization(
    input: CreateNewTeamsEduOrganizationInput!
  ): CreateNewTeamsEduOrganizationOutput!

  # Sets the settings that control the repl view outside the workspace.
  setReplViewSettings(
    input: SetReplViewSettingsInput!
  ): SetReplViewSettingsOutput!
  createTeacherVerificationResponse(
    input: CreateTeacherVerificationResponseInput!
  ): CreateTeacherVerificationResponseOutput!

  # Escalate a report for admins to review.
  escalateBoardReport(id: Int!): EscalateBoardUserOutput!

  # Review a Template to either promote or demote it from the create Repl form
  reviewTemplate(input: ReviewTemplateInput!): ReviewTemplateOutput!
  createAsanaSupportTask(
    input: CreateAsanaSupportTaskInput!
  ): CreateAsanaSupportTaskOutput
  createAsanaFeedbackTask(
    input: CreateAsanaFeedbackTaskInput!
  ): CreateAsanaFeedbackTaskOutput!

  # When `active` is true, either find and update an existing order or charge the user and create a new one. When `active` is false, either update an existing order or return an error if none is found.This mutation is maintained for backwards compatibility with themobile app, prefer updatePrivatePowerUp2 instead for new implementations.
  updatePrivatePowerUp(active: Boolean!): UpdatePrivatePowerUpOutput!

  # When `active` is true, either find and update an existing order or charge the user and create a new one. When `active` is false, either update an existing order or return an error if none is found.Unlike its legacy equivalent, returns a currentUser type so thatclients can fetch updated balance, power ups, etc as part of the mutation.
  updatePrivatePowerUp2(active: Boolean!): UpdatePrivatePowerUp2Output!

  # Deletes all community bans on a user.
  unbanCommunityUser(input: UnbanCommunityUserInput!): UnbanCommunityUserOutput!

  # Changes a repls language to Nix, does not do any migrations, only updates metadata
  changeLanguageToNix(id: String!, lang: String!): ChangeLanguagetoNixOutput!

  # Unpublish a user's repl from the community and notify the user.
  moderatorUnpublish(input: ModeratorUnpublishInput!): ModeratorUnpublishOutput!
  createUserCourse(input: CreateUserCourseInput!): CreateUserCourseOutput
  createUserCourseLesson(
    input: CreateUserCourseLessonInput!
  ): CreateUserCourseLessonOutput
  completeUserCourseLesson(
    input: CompleteUserCourseLessonInput!
  ): UpdateUserCourseLessonOutput
  restartUserCourseLesson(
    input: RestartUserCourseLessonInput!
  ): RestartUserCourseLessonOutput
  setTemplateCategoryRepl(
    input: SetTemplateCategoryReplInput!
  ): SetTemplateCategoryReplOutput
  unsetTemplateCategoryRepl(
    input: UnsetTemplateCategoryReplInput!
  ): UnsetTemplateCategoryReplOutput
  createAsanaFeedbackTaskReturnGID(
    input: CreateAsanaFeedbackTaskInputReturnGID!
  ): CreateAsanaFeedbackTaskOutputReturnGID!

  # Sends a user an in-app notification from a moderator or an admin.
  moderatorNotification(
    input: ModeratorNotificationInput!
  ): ModeratorNotificationOutput!
  createBounty(input: CreateBountyInput!): CreateBountyOutput!
  editBounty(input: EditBountyInput!): EditBountyOutput!

  # Cancels a Bounty by refunding the poster, marking the status as closed and unlisting the bounty
  cancelBounty(input: CancelBountyInput!): CancelBountyOutput!
  createBountyApplication(
    input: CreateBountyApplicationInput!
  ): CreateBountyApplicationOutput!
  createBountySubmission(
    input: CreateBountySubmissionInput!
  ): CreateBountySubmissionOutput!
  createBountySubmissionReview(
    input: CreateBountySubmissionReviewInput!
  ): CreateBountySubmissionReviewOutput!
  reviewBountyApplication(
    input: ReviewBountyApplicationInput!
  ): ReviewBountyApplicationOutput!
  moderateBountyApplication(
    input: ModerateBountyApplicationInput!
  ): ModerateBountyApplicationOutput!
  setBountyUnlisted(
    bountyId: Int!
    isUnlisted: Boolean!
  ): SetBountyUnlistedOutput!
  forceSolverToAbandonBountyAsStaff(
    input: ForceSolverToAbandonBountyAsStaffInput!
  ): ForceSolverToAbandonBountyAsStaffOutput!
  cancelBountyAsStaff(
    input: CancelBountyAsStaffInput!
  ): CancelBountyAsStaffOutput!

  # Allows a Bounty hunter to abandon a Bounty for which they have been accepted
  abandonBounty(input: AbandonBountyInput!): AbandonBountyOutput!
  removeBountyApplicationAsModerator(
    input: RemoveBountyApplicationAsModeratorInput!
  ): RemoveBountyApplicationAsModeratorOutput!
  removeBountyApplicationAsApplicant(
    input: RemoveBountyApplicationAsApplicantInput!
  ): RemoveBountyApplicationAsApplicantOutput!
  reviewBountyHunter(input: ReviewBountyHunterInput!): ReviewBountyHunter!
  removeBountyHunterReviewAsStaff(
    input: RemoveBountyHunterReviewAsStaffInput!
  ): RemoveBountyHunterReviewAsStaffOutput!
  sendBountyChat(input: SendBountyChatInput!): SendBountyChatOutput!
  markBountyChatRead(input: MarkBountyChatReadInput!): MarkBountyChatReadOutput!
  hireBountyHunterService(
    input: HireBountyHunterServiceInput!
  ): HireBountyHunterServiceOutput!
  setGpu(replId: ID!, enabled: Boolean!): SetGpuOutput!
  setStorageCapacity(input: SetStorageCapacityInput!): SetStorageCapacityOutput!
  setUserStorageQuota: SetUserStorageQuotaOutput!

  # Creates a hosted Stripe checkout session for a Cycles purchase which the caller can redirect the user to
  createCyclesStripeCheckoutSession(
    input: CreateCyclesStripeCheckoutSessionInput!
  ): createCyclesStripeCheckoutSession
  bulkModerate(input: BulkModerateInputArg!): BulkModerateOutput

  # When `active` is true, either find and update an existing order or charge the user and create a new one. When `active` is false, either update an existing order or return an error if none is found
  updateGhostwriterPowerUp(
    input: UpdateGhostwriterPowerUpInput!
  ): UpdateGhostwriterPowerUpOutput!

  # Takedown a repl and prevent it waking up via proxy but still available via the workspace.
  replBootStatusStopRepl(replId: String!): ReplBootStatusStopRepl!
  sendTip(input: SendTipInput!): SendTipOutput!

  # Creates a Neon database for the given user and repl
  createNeonDatabase(input: CreateNeonDatabaseInput!): CreateNeonDatabaseOutput!

  # Deletes a Neon database
  deleteNeonDatabase(input: DeleteNeonDatabaseInput!): DeleteNeonDatabaseOutput!

  # Freezes a Neon database
  freezeNeonDatabase(input: FreezeNeonDatabaseInput!): FreezeNeonDatabaseOutput!

  # Unfreezes a Neon database
  unfreezeNeonDatabase(
    input: UnfreezeNeonDatabaseInput!
  ): UnfreezeNeonDatabaseOutput!
  asanaSupportRequest(
    input: AsanaSupportRequestInput!
  ): AsanaSupportRequestOutput!
  failHostingBuild(input: FailHostingBuildInput!): FailHostingBuildOutput

  # Boost a Repl
  boostRepl2(input: BoostRepl2Input!): BoostRepl2Output!

  # Resolves an image scan.
  resolveImageScan(imageScanClassificationId: Int!): ImageScanType!
  registerPushDeviceSession(
    input: RegisterPushDeviceSessionInput!
  ): RegisterPushDeviceSessionOutput!
  unregisterPushDeviceSession(
    input: UnregisterPushDeviceSessionInput!
  ): UnregisterPushDeviceSessionOutput!

  # Pays an invoice
  acceptInvoice(
    # The ID of the invoice to be paid.
    id: String!
  ): AcceptInvoiceOutput!

  # Decline an invoice (called by invoice recipient)
  denyInvoice(
    # The ID of the invoice to be declined.
    id: String!
  ): DenyInvoiceOutput!

  # Install an extension. If replId is not provided, the extension will be installed to the user
  installExtension(
    extensionId: String!
    replId: String
  ): InstallExtensionOutput!

  # Add a Repl that can authorize as its owner using Repl Identity
  addReplIdentityAllowedRepl(
    input: AddReplIdentityAllowedReplInput!
  ): AddReplIdentityAllowedRepl!

  # Remove an authorized Repl so it can no longer authorize as its owner using Repl Identity
  deleteReplIdentityAllowedRepl(
    input: DeleteReplIdentityAllowedReplInput!
  ): DeleteReplIdentityAllowedRepl!

  # Create an invoice addressed to a user.
  createInvoice(
    # The user the invoice should be sent to.
    userId: Int!

    # The amount the user should be billed for.
    amount: Int!

    # A title for the invoice
    title: String!

    # A description of the invoice
    description: String!

    # The URL the invoice page should redirect to on invoice approval/denial.
    redirectUrl: String
  ): CreateInvoiceOutput!

  # Confirm an approved invoice & finalize transaction.
  confirmInvoice(
    # The ID of the invoice to be cancelled.
    id: String!
  ): ConfirmInvoiceOutput!

  # Cancel an invoice.
  cancelInvoice(
    # The ID of the invoice to be cancelled.
    id: String!
  ): CancelInvoiceOutput!

  # Remove an extension installation
  uninstallExtension(installationId: String!): UninstallExtensionOutput!
  deployHostingBuild2(
    input: DeployHostingBuild2Input!
  ): DeployHostingBuild2Output

  # Send a push notification to all staff users
  sendPushToStaff(input: SendPushToStaffInput!): SendPushToStaff!
  deleteThreadMessage(messageId: String!): DeleteThreadMessageOutput

  # Change the user's subscription
  changeSubscription(input: ChangeSubscriptionInput!): ChangeSubscriptionOutput!

  # Remove a user's  profile picture or cover image
  adminRemoveUserImage(
    username: String!
    reason: String!
    deleteProfilePicture: Boolean
    deleteCoverImage: Boolean
  ): AdminRemoveUserImageOutput!

  # Create a setup intent for the requesting user. Use this to save a payment method for future use.
  createSetupIntent: CreateSetupIntentOutput!

  # Update the Auto-Refill configuration for the requesting user.
  updateCyclesAutoRefillConfiguration(
    input: UpdateCyclesAutoRefillConfigurationInput!
  ): UpdateCyclesAutoRefillConfigurationOutput!

  # Stores the ID for an App Store transaction if one doesn't already exist
  getOrCreateAppStoreCustomer: AppStoreCustomerOutput!

  # Stores the ID for an App Store transaction if one doesn't already exist
  getOrCreatePlayStoreCustomer: PlayStoreCustomerOutput!

  # Create a Replit Checkout Session for a one-time purchase. The clientSecret must be used to submit to Stripe using stripe.js to complete the purchase. One side effect of this mutation is that it will update the user's payment method to the one that is currently saved in Stripe if they haven't saved a payment method in Replit.
  createReplitOneTimeCheckoutSession(
    input: CreateReplitOneTimeCheckoutSessionInput!
  ): CreateReplitOneTimeCheckoutSessionOutput!

  # Create a Replit Checkout Session for a plan subscription. The clientSecret must be used to submit to Stripe using stripe.js to complete the purchase. One side effect of this mutation is that it will update the user's payment method to the one that is currently saved in Stripe if they haven't saved a payment method in Replit.
  createReplitPlanCheckoutSession(
    input: CreateReplitPlanCheckoutSessionInput!
  ): CreateReplitPlanCheckoutSessionOutput!

  # Remove a repl's icon image as an administrator.
  adminRemoveReplIcon(
    replUrl: String!
    reason: String!
  ): AdminRemoveReplIconOutput!

  # Creates a Repository on GitHub
  createGithubRepo(input: CreateGithubRepoInput!): CreateGithubRepoOutput!

  # Increase account-level egress with an add-on
  egressLimitAddOn(input: EgressLimitAddOnInput!): EgressLimitAddOnOutput!

  # Set a Repls Hosting Tier
  setHostingTier(input: SetHostingTierInput!): SetHostingTierOutput!
  deployExtension(
    extensionId: String!
    replId: String!
    outputDirectory: String!
  ): DeployExtensionOutput!

  # Send a deployment lifecycle command
  sendDeploymentLifecycleCommand(
    input: SendDeploymentLifecycleCommandInput!
  ): SendDeploymentLifecycleCommandOutput!
  setUserKeybindings(input: SetUserKeybindingsInput!): SetUserKeybindingsOutput!

  # Creates a new extension
  createExtension(
    name: String!
    description: String!
    url: String
  ): CreateExtensionOutput!
}

type ToursSeenMuationResult {
  name: String!
  success: Boolean!
}

type UpdateReplPayload {
  repl: Repl!
}

input UpdateReplInput {
  id: String!
  title: String
  description: String
  imageUrl: String
  iconUrl: String
  isPrivate: Boolean
  isStarred: Boolean
  language: String
  templateLabel: String
  isServer: Boolean
  isVnc: Boolean
  removeDomain: String
  doClone: Boolean
}

union UpdateReplTimeUpdatedOutput = UserError | NotFoundError | Repl

type UpdatePostPayload {
  post: Post!
}

input UpdatePostInput {
  id: Int!
  title: String
  body: String
  isPinned: Boolean
  postType: String
  isLocked: Boolean
  boardId: Int
  replId: String
  showHosted: Boolean
  isHidden: Boolean
}

union PinReplToProfileOutput =
    UnauthorizedError
  | UserError
  | NotFoundError
  | Repl

union UnpinReplFromProfileOutput =
    UnauthorizedError
  | UserError
  | NotFoundError
  | Repl

union ReportReplCommentOutput = UserError | UnauthorizedError | BoardReport

union ReportBountyOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | BoardReport

union ReportBountyApplicationOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | BoardReport

union DashboardItem = Repl | ReplFolder

enum NotificationContext {
  classroom
  board
  multiplayer
  team
  annotation
}

union MultiplayerInviteOutput = MultiplayerInvite | ReplPermission | UserError

input UpdateBoardTrendingAlgorithmSettingsInput {
  postsExponent: Float!
  postsCommentWeight: Float!
  commentsExponent: Float!
}

union UpdateUserOutput = CurrentUser | UserError

union CreateReplOutput = UserError | Repl

input CreateReplInput {
  title: String
  description: String
  language: String
  folderId: String
  gitRemoteUrl: String
  originId: String
  replReleaseId: String
  isPrivate: Boolean
  forkToPersonal: Boolean
  teamId: Int
  stackId: Int
}

input UpdateCurrentUserInput {
  firstName: String
  lastName: String
  bio: String
  location: String
  profileImageId: Int
  emailNotifications: Boolean
}

union SelectReplContinent =
    UnauthorizedError
  | NotFoundError
  | UserError
  | ServiceUnavailable
  | TooManyRequestsError
  | CurrentUser

# Input for the selectReplContinent mutation.
input SelectReplContinentInput {
  continent: ReplContinentId!
}

type CluiMutation {
  # Admin CLUI operations
  admin: AdminCluiMutation

  # Manage your account
  account: UserCliAccountMutation

  # Moderator CLUI operations
  moderator: ModeratorCluiMutation

  # List and restore deleted repls and folders
  trash: TrashMutation

  # View and manage your teams
  team: TeamMutation

  # View and manage extensions you've made
  extension: ExtensionMutation
}

type AdminCluiMutation {
  # View, impersonate, ban, etc.
  user: AdminCliUserMutation

  # Manage site settings
  site: AdminCliSiteMutation

  # Manage user roles
  roles: AdminCliRolesMutation

  # Provision a team
  team: AdminTeamMutation

  # Manage site banner
  banners: AdminCliBannersMutation

  # Set app wide key/value
  appEnv: AdminCliAppEnvMutation

  # Poison, cleanse, etc.
  repl: AdminCliReplMutation

  # Configure templates
  templates: AdminCliTemplatesMutation

  # View and publish curriculum hub content
  curriculum: AdminCurriculumHubMutation

  # Delete, etc.
  hostingDeployment: AdminCliHostingDeploymentsMutation

  # Configure organizations
  org: AdminCliBillingOrgsMutation

  # Configure subscriptions
  subscriptions: AdminCliSubscriptionsMutation

  # View and update manually curated content for trending
  curation: ManualCurationMutation

  # View and manage extensions on Replit
  extension: AdminCliExtensionMutation

  # Configure tours
  tours: AdminCliToursMutation
}

type AdminCliUserMutation {
  # This does terrible things to a user's account. This is not a Repl Talk ban, this is a SITE WIDE BAN. All their Repls go poof and they will no longer be able to access their account.
  ban(
    # User's username or email
    user: String!

    # Reason for ban
    reason: String!
  ): CluiOutput

  # This makes everything better again. This is not a repl talk unban, this is a SITE WIDE UNBAN. All their repls come back and they will have to access their account again.
  unban(
    # User's username or email
    user: String!

    # set the first name of the user
    firstName: String!

    # set the last name of the user
    lastName: String!

    # (optional) force restore repls by this time (2021-12-31T23:59:59.999Z in UTC)
    time: String
  ): CluiOutput

  # Restore a users account and their repls
  restore(
    # User's username or email
    user: String!

    # (optional) force restore repls by this time (2021-12-31T23:59:59.999Z in UTC)
    time: String
  ): CluiOutput

  # Change a users email
  changeEmail(
    # User's username or email
    user: String!

    # set the email of the user
    email: String!
  ): CluiOutput

  # Change a users username
  changeUsername(
    # User's username or email
    user: String!

    # set the username of the user
    username: String!
  ): CluiOutput

  # Impersonate a user (username, email, or repl url)
  impersonate(
    # User's username or email
    user: String!
  ): CluiOutput

  # Modify a user's trust level
  trust(
    # User's username or email
    user: String!

    # Desired trust level; empty removes the trust level
    level: UserTrustEnum
  ): CluiOutput

  # Override a user's default cluster
  cluster(
    # User's username or email
    user: String!

    # Override cluster; empty removes the override. Note that usernames are not namespaced well and changes here are shared across dev/production.
    cluster: String
  ): CluiOutput

  # Provisions a trial subscription for a set amount of time
  provision(
    # Username or email of existing user
    username: String!

    # Plan
    planPrefix: CLUIIndividualPlanPrefix!

    # Duration of trial subscription (in months)
    months: Int!
  ): CluiOutput

  # Expires a user subscription
  deprovision(
    # Username or email of existing user
    username: String!
  ): CluiOutput

  # Mark the user as email verified
  verify(
    # Username or email of existing user
    username: String!
  ): CluiOutput

  # View and manage users' Cycles balances
  cycles: AdminCliUserCyclesMutation

  # View and manage users' PowerUps
  powerUps: AdminCliUserPowerUpsMutation

  # View and manage users' IAP subscriptions
  iap: AdminCliUserIAPMutation

  # Reconcile or reset a user's egress for the current month
  egress(
    # User's username or email
    user: String!

    # Reset (to zero) or reconcile (match the user and Repl values)
    method: EgressUsageMethod!
  ): CluiOutput
}

enum UserTrustEnum {
  low
}

enum CLUIIndividualPlanPrefix {
  hacker
  hacker_pro
}

type AdminCliUserCyclesMutation {
  # Retire cycles from a user. Please read these guidelines first: https://replit.com/@util/handbook#cycles/clui_rules.md
  retire(
    # The username or email of the user
    username: String!

    # The number of cycles to retire.
    cycles: Int!

    # The reason for retiring cycles.
    internalComment: String!
  ): CluiOutput

  # Grant cycles to a user. Please read these guidelines first: https://replit.com/@util/handbook#cycles/clui_rules.md
  grant(
    # The username or email of a single user, or a comma-separated list of user IDs (up to 100).
    target: String!

    # The number of cycles to grant.
    cycles: Int!

    # The reason for granting cycles.
    internalComment: String!
  ): CluiOutput

  # Manage a user's Cycles for cash out
  cashOut: AdminCliUserCyclesCashOutMutation
}

type AdminCliUserCyclesCashOutMutation {
  # Pledge Cycles to be cashed out for a user.
  pledge(
    # The username or email of the user cashing out cycles
    user: String!

    # The number of Cycles to pledge for cash out
    cycles: Int!

    # The percent of the Cycles Replit will charge as a fee for cash out.
    feePercent: CashOutFeePercentEnum!
  ): CluiOutput

  # Resolve the cash out process by recording a wallet's pledged Cycles as paid.
  paid(
    # The username or email of the user cashing out cycles
    user: String!
  ): CluiOutput

  # Resolve the cash out process by refunding a user their pledged Cycles.
  refund(
    # The username or email of the user cashing out cycles
    user: String!
  ): CluiOutput
}

enum CashOutFeePercentEnum {
  default
  fifteen
}

type AdminCliUserPowerUpsMutation {
  # Create a Power Ups trial for a user (assuming one doesn't exist yet)
  createTrial(
    # Usernames or emails, separated by commas
    user: String!

    # The type of Power Up
    powerUp: PowerUpTrialTypeEnumType!

    # The expiry date to set for the trial (used as an input to new Date() JavaScript call)
    expiry: String!
  ): CluiOutput

  # Edit Power Ups trials for a user (assumes one exists)
  editTrial(
    # The username or email of the user
    user: String!

    # The type of Power Up
    powerUp: PowerUpTrialTypeEnumType!

    # The expiry date to set for the trial (used as an input to new Date() JavaScript call)
    expiry: String!
  ): CluiOutput
}

enum PowerUpTrialTypeEnumType {
  ghostwriter
  private
}

type AdminCliUserIAPMutation {
  # Create an IAP subscription for a user (if one doesn't exist yet). 1 month duration.
  createIAPSubscription(
    # The username or email of the user
    user: String!

    # The plan id (defaults to current Pro plan)
    planId: String

    # The provider name (defaults to apple)
    providerName: String
  ): CluiOutput

  # Expire an IAP subscription for a user (if one exists).
  expireIAPSubscriptions(
    # The username or email of the user
    user: String!
  ): CluiOutput
}

enum EgressUsageMethod {
  reconcile
  reset
}

type AdminCliSiteMutation {
  # Anyone who loaded the client before the set date will be asked to reload
  setLastUpdateTime(
    # epoch in milliseconds (leave empty for Date.now())
    date: Int
  ): CluiOutput
}

type AdminCliRolesMutation {
  # Adds role to user
  add(
    # The role to add
    role: UserRoles!

    # User's username or email
    user: String!
  ): CluiOutput

  # Removes role from user
  remove(
    # The role
    role: UserRoles!

    # User's username or email
    user: String!
  ): CluiOutput
}

type AdminTeamMutation {
  # Moves team to destination org.
  moveTeamToOrg(
    # team name
    team: String!

    # org id
    orgId: Int!
  ): CluiOutput

  # Add or remove team member
  addRemoveTeamMember(
    # User's username or email
    user: String!

    # team name
    team: String!

    # Permission level. If the user is already a team member, it will change the permissions level to one selected.
    permissions: TeamPermission

    # Select if you want to remove this member from the team
    remove: Boolean
  ): CluiOutput
}

type AdminCliBannersMutation {
  # Adds a site-wide banner
  add(
    # The message to add
    message: String!
  ): CluiOutput

  # Removes the site-wide banner
  remove: CluiOutput
}

type AdminCliAppEnvMutation {
  # Append a value to an app-wide list variable
  append(
    # The key name
    key: String!

    # The value to append
    value: String!
  ): CluiOutput

  # Remove a value from an app-wide list variable
  remove(
    # The key name
    key: String!

    # The value to remove
    value: String!
  ): CluiOutput

  # Set an app-wide variable
  set(
    # The key name
    key: String!

    # The value
    value: String!
  ): CluiOutput

  # Unset an app-wide variable
  unset(
    # The key to unset
    key: String!
  ): CluiOutput
}

type AdminCliReplMutation {
  # Poison a Repl. Transfers the Repl and all forks (recursively) to the tarpit.
  poison(
    # repl ID
    repl: String!

    # Prevents users from forking this repl and any of its forks (recursive)
    disableForking: Boolean = false
  ): CluiOutput

  # Removes the poison status from the target Repl and all its forks recursively. This moves all those repls back to the appropriate cluster. For heavily forked repls (>20k), this job might time out. In that case you should run the script/cleasneReplTree script locally against production.
  cleanse(
    # repl ID
    repl: String!
  ): CluiOutput

  # Delete a Repl (will appear in the user's trash)
  delete(
    # repl ID
    repl: String!
  ): CluiOutput

  # Takedown a Repl (if the Repl is deleted but still running)
  takedown(
    # repl ID
    repl: String!
  ): CluiOutput
}

type AdminCliTemplatesMutation {
  # Unpublish a template.
  unpublish(
    # The template repl id
    replId: String!
  ): CluiOutput

  # View and manage template categories
  categories2: AdminCliTemplatesCategoriesMutation
}

type AdminCliTemplatesCategoriesMutation {
  # Add or edit a template category.
  addOrUpdate(
    # The title of the template category, e.g. Games
    title: String

    # The description of the template category, e.g. Learn how to build games.
    description: String

    # The image url to be displayed with the template category, e.g. /public/images/cat-1.jpg Note: currently all category images are hosted locally and need to be uploaded via PR.
    imageUrl: String

    # A number which will determine a categories position on the templates page, e.g 2
    order: Int

    # Select if you want to update an already existing template category
    update: Boolean

    # ID of the template category to update if applicable
    updateTemplateId: Int
  ): CluiOutput

  # Delete a template category.
  delete(
    # The id of the template category to be deleted.
    id: Int!
  ): CluiOutput
}

type AdminCurriculumHubMutation {
  # Export a team as curriculum
  exportCurriculum(
    # Source team username
    team: String!
  ): CluiOutput

  # Export a team as curriculum
  changeCurriculumStatus(
    # Curriculum version id
    versionId: Int!

    # Version status
    status: CurriculumVersionStatus!
  ): CluiOutput
}

enum CurriculumVersionStatus {
  draft
  in_review
  published
}

type AdminCliHostingDeploymentsMutation {
  # Delete a Hosting Deployment.
  delete(
    # The ID of the repl associated with your hosting deployment
    replId: String!
  ): CluiOutput
}

type AdminCliBillingOrgsMutation {
  # Add or remove an admin from the org.
  addRemoveAdmin(
    # The org id
    orgId: Int!

    # The user id to add or remove as an admin.
    userId: Int!

    # Select if you want to remove this user from the org
    remove: Boolean
  ): CluiOutput

  # Verify or reject teachers
  verifyTeacher(
    # User IDs (comma or space separated)
    userIds: String!

    # Verification action
    action: action!
  ): CluiOutput

  # Provision an organization
  provision(
    # Username of the organization owner
    owner: String!

    # Organization name
    name: String!

    # Team name
    teamName: String

    # Plan prefix
    plan: CLUITeamOrganizationPlanPrefix!

    # Billing interval
    interval: CLUITeamOrganizationBillingInterval

    # When the trial period ends (yyyy-mm-dd)
    trialEnd: String

    # Seat count (only applies to per-seat plans)
    seatCount: Int
    customDeal: Boolean

    # When the subscription ends (yyyy-mm-dd); only applicable to custom deals
    timeExpired: String
  ): CluiOutput
}

enum action {
  verify
  reject
}

enum CLUITeamOrganizationPlanPrefix {
  teams_pro
}

enum CLUITeamOrganizationBillingInterval {
  monthly
  annual
}

type AdminCliSubscriptionsMutation {
  # Override subscriptions (leave blank to view overrides)
  override(
    # username or email
    username: String

    # organization ID
    orgId: Int

    # Override expiration (format: yyyy-mm-dd)
    overrideExpiration: String

    # Ignore expiration? (infinite subscription)
    ignoreExpiration: OverrideBehaviorEnum

    # Override quantity (only for seat-based plans)
    overrideQuantity: Int

    # Ignore quantity? (infinite quantity)
    ignoreQuantity: OverrideBehaviorEnum

    # Why is this override being modified? (required if any override provided)
    reason: String
  ): CluiOutput
}

enum OverrideBehaviorEnum {
  enabled
  disabled
}

type ManualCurationMutation {
  # Make a Repl trend in the community
  add(
    # The Repl URL to add to the trending stack
    url: String!
  ): CluiOutput

  # remove a selected Repl from the curated homepage picks
  remove(
    # The Repl URL to remove from the trending list
    url: String!
  ): CluiOutput

  # reset the redis cache for trending items manually (add & remove do this automatically)
  refresh: CluiOutput
}

type AdminCliExtensionMutation {
  # This deletes an extension by its id. Remember to inform the extension creator why we are deleting their extension, and post in the #p_extensions channel
  delete(
    # The extension's ID
    extensionId: String!
  ): CluiOutput

  # This updates an extension by its id. Remember to inform the extension creator what we are changing, and post in the #p_extensions channel
  update(
    # The extension's ID
    extensionId: String!

    # The extension's new name
    name: String

    # The extension's new description
    description: String

    # The extension's new url
    url: String

    # Whether or not the extension is blessed. (true / false / [leave blank])
    isBlessed: String
  ): CluiOutput
}

type AdminCliToursMutation {
  # Updates whether a tour has been seen for a user.
  updateTourSeen(
    # User's username or email
    user: String!

    # The name of the tour to update
    tourName: String!

    # Whether or not the tour should be marked as seen
    shouldBeMarkedAsSeen: Boolean
  ): CluiOutput
}

type UserCliAccountMutation {
  # Change your username (this can only be done once)
  changeUsername(username: String!): CluiOutput
}

type ModeratorCluiMutation {
  # Unpublish a repl
  unpublish(
    # The repl's url
    replUrl: String!

    # Reason for unpublishing (10 words or less)
    reason: String!
  ): CluiOutput

  # Remove a tag on Apps
  removeTag(
    # The tag (do not include the #)
    tag: String!

    # Reason for removing tag (5 words or less)
    reason: String!

    # This will ban the tag from future use and send a Warn to any user that has used this tag.
    banTag: Boolean!
  ): CluiOutput

  # Ban, warn, view-warns, etc.
  user: ModeratorCliUserMutation
}

type ModeratorCliUserMutation {
  # Ban a user from Repl Talk.
  ban(
    # User's username or email
    user: String!

    # Reason for ban
    reason: String
  ): CluiOutput

  # Warn a user.
  warn(
    # User's username or email
    user: String!

    # Reason for warn
    reason: String!
  ): CluiOutput

  # Remove a warning by its id.
  removeWarn(
    # User's username or email
    user: String!

    # Id of warning to remove
    warnId: Int!
  ): CluiOutput
}

type TrashMutation {
  # Restore a deleted Repl by its title
  restoreRepl(
    # title of Repl that will be restored
    title: String!
  ): CluiOutput

  # Restore a deleted Repl folder by its name
  restoreFolder(
    # name of Repl folder that will be restored
    name: String!

    # restore Repls in folder
    andRepls: Boolean
  ): CluiOutput
}

type TeamMutation {
  # transfer one of your Repls to a team
  transferRepl(
    # The Repl slug or url
    repl: String!

    # team name
    team: String!
  ): CluiOutput

  # Forks an existing Repl to create a team project
  forkReplToProject(
    # The Repl url
    replUrl: String!

    # If "checked" it will create a group project (you can not change this later)
    isGroupProject: Boolean = false

    # team name
    team: String!
  ): CluiOutput

  # restore one of your deleted projects in a team
  restoreProject(
    # The title of project that will be restored
    project: String!

    # team name
    team: String!

    # If checked, will restore student submissions for this project
    submissions: Boolean
  ): CluiOutput

  # restore one of your deleted repls in a team (WARNING: use restoreEduProject command for Teams for Education projects, not this command!)
  restoreRepl(
    # The title of repl that will be restored
    title: String!

    # team name
    team: String!
  ): CluiOutput

  # Update an existing team invite link
  updateInvite(
    # The invite link
    inviteLink: String!

    # Whether the link is a privacy link (read more here: https://docs.replit.com/teams-edu/inviting-teachers-students#invite-students-in-privacy-mode)
    isPrivacyLink: Boolean
  ): CluiOutput
}

type ExtensionMutation {
  # Create a new extension
  create(
    # The extension's URL
    url: String!

    # The extension's name
    name: String!

    # The extension's description
    description: String!
  ): CluiOutput

  # Update an extension
  update(
    # The extension's ID
    extensionId: String!

    # The extension's new name
    name: String

    # The extension's new description
    description: String

    # The extension's new url
    url: String
  ): CluiOutput

  # Delete an extension
  delete(
    # The extension's ID
    extensionId: String!
  ): CluiOutput
}

union LinkReplDomain2 =
    UnauthorizedError
  | ServiceUnavailable
  | NotFoundError
  | Repl

union CreateAnnotationAnchorOutput = UserError | AnnotationAnchor

input AnnotationAnchorInput {
  id: String!
  replId: String!
  path: String
  otVersion: Int
  indexStart: Int
  indexEnd: Int
  isResolved: Boolean
  isGeneral: Boolean
}

input AnnotationMessageInput {
  id: String!
  text: String!
  mentions: [String!]
  anchorId: String
}

input AnnotationHighlightInput {
  precode: String
  code: String
  postcode: String
}

union CreateAnnotationMessageOutput = UserError | AnnotationAnchor

union UpdateAnnotationAnchorOutput = UserError | AnnotationAnchor

input AnnotationAnchorChangesInput {
  path: String
  otVersion: Int
  indexStart: Int
  indexEnd: Int
  isResolved: Boolean
}

input DeleteTeamInput {
  teamId: Int!
  cancelationReason: String
}

input UpdateTeamInput {
  id: Int!
  username: String
  description: String
  displayName: String
  profileImage: String
}

union RemoveTeamMemberOutput = UserError | Team

input RemoveTeamMemberInput {
  teamId: Int!
  memberId: Int!
}

union LeaveTeamOutput = UserError | Team

union CreateTeamInviteOutput = UserError | Team

input CreateTeamInviteInput {
  teamId: Int!
  usernameOrEmail: String!
}

union DeleteTeamInviteOutput = UserError | Team

input DeleteTeamInviteInput {
  teamId: Int!
  usernameOrEmail: String
  inviteId: Int
}

union CreateTeamInviteLinkOutput = UserError | Team

union DeleteTeamInviteLinkOutput = UserError | Team

union UpdateTeamUserPermissionsOutput = UserError | Team

input UpdateTeamUserPermissionsInput {
  # The ID of the team
  id: Int!

  # The user whose permissions should be changed.
  user: Int!

  # The permissions the user should get
  permissions: TeamPermission!
}

union CreateReplTemplateOutput = UserError | ReplTemplate

input CreateReplTemplateInput {
  replId: String!
  imageUrl: String
  isPublished: Boolean
  dueDate: String
}

union CreateReplAsTemplateOutput = UserError | ReplTemplate

input CreateReplAsTemplateInput {
  title: String!
  language: String
  originId: String
  replReleaseId: String
  description: String
  teamId: Int!
  imageUrl: String
  isPublished: Boolean
  isGroupProject: Boolean
  dueDate: String
  availableStartDate: String
  availableEndDate: String
  restrictAfterSubmit: Boolean
  allowSelfGrouping: Boolean
  selfGroupSize: Int
  stackId: Int
}

union UpdateReplTemplateOutputType = UserError | ReplTemplate

input UpdateReplTemplateInput {
  id: Int!
  imageUrl: String
  isPublished: Boolean
  submissionGroups: [SubmissionGroupInput]
  dueDate: String
  availableStartDate: String
  availableEndDate: String
  allowSelfGrouping: Boolean
  selfGroupSize: Int
}

input SubmissionGroupInput {
  submissionId: Int
  userIds: [Int]!
}

union SubmitReplOutput = Repl | UserError

union UnsubmitReplOutput = Repl | UserError

union ReviewReplOutput = Repl | UserError

union CreateReplSubmissionOutput = UserError | Repl

union UpdateTeamInviteLinkEduSignupOutput = UserError | Team

union TemplateTestOutput = ReplTemplateTest | UserError

input CreateTemplateTestInput {
  name: String!
  input: String!
  output: String!
  type: ReplTemplateTestType!
  templateId: Int!
}

union ReplUnitTestOutput = ReplUnitTest | UserError

input CreateReplUnitTestInput {
  name: String!
  code: String!
  failureMessage: String
  replId: String!
}

input UpdateReplUnitTestInput {
  name: String
  code: String
  failureMessage: String
  testId: Int!
}

union ReplUnitTestMetaOutput = ReplUnitTestMeta | UserError

input CreateReplUnitTestMetaInput {
  imports: String
  initialization: String
  setup: String
  tearDown: String
  replId: String!
}

input UpdateReplUnitTestMetaInput {
  imports: String
  initialization: String
  setup: String
  tearDown: String
  replId: String!
}

union UpdateReplUnitTestLastRunOutput =
    UpdateReplUnitTestLastRunUpdatedTests
  | UserError

type UpdateReplUnitTestLastRunUpdatedTests {
  updatedTests: [ReplUnitTestOutput!]!
}

input UpdateReplUnitTestLastRunInput {
  replId: String!
  results: [UpdateReplUnitTestLastRunInputResults!]!
}

input UpdateReplUnitTestLastRunInputResults {
  testId: Int!
  didPass: Boolean!
}

union CreateLanguageConnectionMetadataOutput = GovalMetadata | UserError

# An object containing the connection metadata for a repl
type GovalMetadata {
  token: String!
  gurl: String!
  conmanURL: String!
}

# An object containing the metadata for a cluster
input ClusterMetadata {
  id: String!
  gurl: String!
  conmanURL: String!
}

union DeleteReplTemplateOutput = ReplTemplate | UserError

input UpdateTemplateTestInput {
  name: String
  input: String
  output: String
  type: ReplTemplateTestType
  testId: Int!
}

input UpdateEditorPreferencesInput {
  isLayoutStacked: Boolean
  theme: String
  fontSize: Int
  indentIsSpaces: Boolean
  indentSize: Int
  keyboardHandler: String
  wrapping: Boolean
  codeIntelligence: Boolean
  codeSuggestion: Boolean
  completeCodeEngine: String
  chatEngine: String
  accessibleTerminal: Boolean
  multiselectModifierKey: String
  webviewAutoOpenOnPortOpened: Boolean
  extraDelight: Boolean
  minimapDisplay: String
}

union CreateReplCommentOutput = ReplComment | UserError | UnauthorizedError

input CreateReplCommentInput {
  replId: String!
  body: String!
}

union ReplOutput = Repl | UserError

input SetReplCommentSettingsInput {
  replId: String!
  enabled: Boolean!
}

union CreateReplCommentReplyOutput = ReplComment | UserError | UnauthorizedError

input CreateReplCommentReplyInput {
  replCommentId: Int!
  body: String!
}

input OwnAnonReplInput {
  replId: String!
}

input UpdateReplCommentInput {
  id: Int!
  body: String!
}

input CSVFileInput {
  teamId: Int!
  content: String!
}

union ResetPrivacyStudentPasswordOutput =
    ResetPrivacyStudentPasswordSuccess
  | UserError

type ResetPrivacyStudentPasswordSuccess {
  success: Boolean!
}

union DeletedProjectAndSubmissionOutput = Team | UserError

union SetAlwaysOnOutput = UserError | Repl

union CreateReplReleaseOutput =
    UnauthorizedError
  | UserError
  | NotFoundError
  | Repl

input CreateReplReleaseInput {
  replId: String!
  description: String!
}

union RevertReplReleaseOutput =
    UnauthorizedError
  | UserError
  | NotFoundError
  | Repl

input RevertReplReleaseInput {
  replId: String!
  releaseId: String!
}

union CreateReplDeployemntOutput =
    UnauthorizedError
  | UserError
  | NotFoundError
  | Repl

input CreateReplDeployemntInput {
  replId: String!
  iconUrl: String!
  description: String!
}

union DeleteReplDeploymentOutput = UserError | NotFoundError | Repl

input DeleteReplDeploymentInput {
  replId: String!
}

union MarkMessagesAsSeenOutput = UserError | AnnotationMessageList

type AnnotationMessageList {
  messages: [AnnotationMessage!]!
}

union CreateReplRunOutput = UserError | NotFoundError | Repl

union UpdateTeamOrganizationOutput =
    UnauthorizedError
  | NotFoundError
  | TeamOrganization

input UpdateTeamOrganizationInput {
  id: Int!
  name: String!
}

union SaveIOTestResultOutput = NotFoundError | UserError

# An input type for telling the server the results of an IO test.
input IOTestResultInput {
  # The output of the program when the test was executed.
  output: String!

  # The status of the test that was executed.
  status: IOTestResultStatus!

  # The ID of the test which was executed on the repl.
  testId: Int!
}

union UpdateTeamMemberOutput = UnauthorizedError | UserError | Team

input UpdateTeamMemberInput {
  # The ID of the team
  teamId: Int!

  # The user whose nickname should be changed.
  userId: Int!

  # Admin assigned nickname for member.
  nickname: String
}

union CreateTeamV2Output = UserError | UnauthorizedError | Team

input CreateTeamV2Input {
  username: String!
  orgId: Int
  displayName: String
  privacyInvite: Boolean
}

union ConnectGoogleClassroomOutput = UserError | NotFoundError | GoogleClassroom

input ConnectGoogleClassroomInput {
  teamId: Int!
  courseId: String!
  courseName: String!
  students: [ConnectGoogleClassroomStudentInput]!
}

input ConnectGoogleClassroomStudentInput {
  # Google profile ID of user
  id: String!

  # Google profile email of user
  email: String!
}

union DeleteMultiplayerInviteLink = UserError | Repl

union ExportTeamSubmissionsOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | ExportTeamSubmissionsResult

type ExportTeamSubmissionsResult {
  folderPath: String!
}

union DisconnectGoogleClassroomOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | Team

input DisconnectGoogleClassroomInput {
  teamId: Int!
}

union CreateReplSubmissionGroupOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | ServiceUnavailable
  | ReplSubmission

input CreateReplSubmissionGroupInput {
  teamId: Int!
  templateId: Int!
}

union JoinReplSubmissionGroupOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | ReplSubmission

input JoinReplSubmissionGroupInput {
  teamId: Int!
  submissionId: Int!
}

union ExportProjectsOverviewOutput =
    NotFoundError
  | UnauthorizedError
  | CurrentUser

input ExportProjectsOverviewInput {
  teamName: String!
  templateIds: [Int!]
}

union ArchviveTeamInput = UserError | NotFoundError | UnauthorizedError | Team

input ArchiveTeamInput {
  teamId: Int!
}

union UnarchiveTeamOutput = UserError | NotFoundError | UnauthorizedError | Team

input UnarchiveTeamInput {
  teamId: Int!
}

union SetLanguageTemplateOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | Repl

input SetLanguageTemplateInput {
  language: String!
  replId: String
  betaReplId: String
}

union SetBetaTemplateOutput = UserError | UnauthorizedError | Repl

input SetBetaTemplateInput {
  replUrlOrId: String
  betaReplUrlOrId: String
}

union CreateStackOutput = Team | User | UserError | UnauthorizedError

input CreateStackInput {
  # Owner of the stack
  userId: Int!

  # Title of the stack
  title: String!

  # Description of the stack
  description: String
}

union ArrangeStackItemOutput =
    Team
  | User
  | UserError
  | UnauthorizedError
  | NotFoundError

input ArrangeStackItemInput {
  # Repl in the stack.
  replId: String!

  # Stack the Repl belongs to. Set to 0 to ungroup the Repl from its existing stack.
  stackId: Int!

  # Stack the Repl previously belonged to.
  previousStackId: Int

  # Desired order in the stack.
  order: Int!
}

union UploadReplAttachmentOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | Repl

input UploadReplAttachmentInput {
  # Repl to own the attachment
  replId: String!

  # File name of attachment
  fileName: String!

  # File contents
  contents: String!

  # ISO timestamp of the last modified date of the attachment
  lastModified: String!
}

union ImportCurriculumOutput = NotFoundError | UnauthorizedError | Team

input ImportCurriculumInput {
  curriculumId: Int!
  versionNumber: Int!
  teamId: Int!
}

union MigrateTeamToStacksOutput = UserError | NotFoundError | Team

union UpdateStackOutput =
    Team
  | User
  | UserError
  | UnauthorizedError
  | NotFoundError

input UpdateStackInput {
  # Id of the stack
  stackId: Int!

  # Title of the stack
  title: String

  # Description of the stack
  description: String
}

union DeleteStackOutput =
    Team
  | User
  | UserError
  | UnauthorizedError
  | NotFoundError

union ArrangeStackOutput =
    Team
  | User
  | UserError
  | UnauthorizedError
  | NotFoundError

input ArrangeStackInput {
  stackId: Int!

  # Desired order with in the user profile
  order: Int!
}

union CreateReplPost2Output =
    UnauthorizedError
  | UserError
  | NotFoundError
  | Post

input CreateReplPost2Input {
  replId: String!
  tags: [String!]
  iconUrl: String
  body: String
  title: String
}

union UnpublishReplFromCommunityOutput =
    NotFoundError
  | UnauthorizedError
  | Repl

input UnpublishReplFromCommunityInput {
  replId: String!
}

union CodexFeedback2Output = UnauthorizedError | NotFoundError | CodexFeedback2

type CodexFeedback2 {
  id: String!
  feedback: CodexFeedbackEnum!
}

enum CodexFeedbackEnum {
  yes
  no
}

input CodexFeedback2Input {
  inferenceId: String!
  feedback: CodexFeedbackEnum!
  inferenceClass: CodexFeedback2CodexInferenceClassEnum!
}

enum CodexFeedback2CodexInferenceClassEnum {
  explanation
  generation
  transformation
  chat
}

union ToggleReplLikeOutput = UserError | NotFoundError | Repl

input ToggleReplLikeInput {
  replId: String!
}

union setFollowing =
    UserError
  | UnauthorizedError
  | NotFoundError
  | FollowResult

type FollowResult {
  user: User
  targetUser: User
}

input setFollowingInput {
  targetUserId: Int!
  shouldFollow: Boolean!
}

union SetBlocking2 = UnauthorizedError | NotFoundError | SetBlocking2Result

type SetBlocking2Result {
  isBlocked: Boolean!
  targetUser: User!
  currentUser: CurrentUser!
}

input SetBlocking2Input {
  targetUserId: Int!
  shouldBlock: Boolean!
}

union SetTemplateCategoryOutput = NotFoundError | Repl

input SetTemplateReplCategoryInput {
  replId: String!
  category: String!
}

union SetOnboardingExperienceOutput =
    UnauthorizedError
  | UserError
  | CurrentUser

enum OnboardingExperience {
  ONBOARDING_EXPERIENCE_NONE
  ONBOARDING_EXPERIENCE_LOW
  ONBOARDING_EXPERIENCE_MEDIUM
  ONBOARDING_EXPERIENCE_HIGH
}

union SetOnboardingIntentOutput = UnauthorizedError | UserError | CurrentUser

enum Intent {
  INTENT_PERSONAL
  INTENT_STUDENT
  INTENT_TEACHER
  INTENT_BUSINESS
}

union CreateReplTemplateModelSolutionOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | Repl

input CreateReplTemplateModelSolutionInput {
  teamId: Int!
  templateId: Int!
  visibleAfterSubmitting: Boolean
  visibleAfterDueDate: Boolean
  visibleAfterPassingTests: Boolean
}

union CreateReplTemplateModelSolutionForkOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | Repl

input CreateReplTemplateModelSolutionForkInput {
  teamId: Int!
  solutionId: Int!
}

union UpdateReplTemplateModelSolutionOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | Repl

input UpdateReplTemplateModelSolutionInput {
  teamId: Int!
  solutionId: Int!
  visibleAfterSubmitting: Boolean
  visibleAfterDueDate: Boolean
  visibleAfterPassingTests: Boolean
}

union UpdateTeamOrganizationMemberOutput =
    UnauthorizedError
  | NotFoundError
  | TeamOrganization

input UpdateTeamOrganizationMemberInput {
  orgId: Int!
  memberId: Int!
  role: TeamMemberRoleEnumType!
}

# Team organization member roles
enum TeamMemberRoleEnumType {
  OWNER
  ADMIN
}

union DeleteTeamOrganizationMemberOutput =
    UnauthorizedError
  | NotFoundError
  | TeamOrganization

input DeleteTeamOrganizationMemberInput {
  orgId: Int!
  memberId: Int!
  retainTeamAccess: Boolean
}

union DeleteTeamOrganizationOutput =
    UnauthorizedError
  | NotFoundError
  | TeamOrganization

input DeleteTeamOrganizationInput {
  orgId: Int!
}

union CreateTeamOrgInviteOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | TeamOrganization

input CreateTeamOrgInviteInput {
  orgId: Int!
  usernameOrEmail: String!
}

union DeleteTeamOrgInviteOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | TeamOrganization

input DeleteTeamOrgInviteInput {
  orgId: Int!
  inviteId: Int!
}

union UpdateSubscription =
    UserError
  | NotFoundError
  | UnauthorizedError
  | UpdateSubscriptionOutput

type UpdateSubscriptionOutput {
  subscriptions: [Subscription!]!
}

type Subscription {
  id: Int!
  quantity: Int!
  isTrial: Boolean!
  timeActivated: Date!
  timeExpired: Date!
  timeCreated: Date!
  timeUpdated: Date!
  timeDeleted: Date
  product: Product!
  status: String
  isGift: Boolean!
}

type Product {
  id: Int!
  planPrefix: String!
  planVariant: String!
  planVersion: String!
  description: String
}

input UpdateSubscriptionInput {
  orgId: Int!
  product: UpdateSubscriptionLineItemInput!
}

input UpdateSubscriptionLineItemInput {
  # Product ID (only if changing subscribed product)
  id: Int

  # Subscription quantity (only if changing quantity)
  quantity: Int
}

union CreateTeamOrgInviteLinkOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | TeamOrganization

union DeleteTeamOrgInviteLinkOutput =
    NotFoundError
  | UnauthorizedError
  | TeamOrganization

union CopyTeamTemplateOutput =
    Team
  | User
  | UserError
  | UnauthorizedError
  | NotFoundError

input CopyTeamTemplateInput {
  # Team project to copy
  templateId: Int!

  # Destination team
  destinationTeamId: Int!

  # Destination stack in team (optional)
  destinationStackId: Int
}

union CopyStacksToTeamOutput =
    Team
  | User
  | UserError
  | UnauthorizedError
  | NotFoundError

input CopyStacksToTeamInput {
  # Stacks and Template IDs selected for copying
  stacks: [stacks!]!

  # Destination team to copy to
  destinationTeamId: Int!

  # Source team to copy from
  sourceTeamId: Int!
}

input stacks {
  # ID of stack selected for copying
  id: Int!

  # List IDs of templates which have been selected for copying
  templateIds: [Int!]!
}

union JoinTeamAsOrgAdminOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | Team

union SetUserSocialsOutput = UserError | UnauthorizedError | CurrentUser

input SetUserSocialsInput {
  socials: [SetUserSocialInput!]!
}

input SetUserSocialInput {
  url: String
  type: UserSocialEnum!
}

enum UserSocialEnum {
  twitter
  facebook
  linkedin
  github
  discord
  youtube
  twitch
  website
}

union UpdateUserSitePresenceOutput =
    ServiceUnavailable
  | UnauthorizedError
  | CurrentUser

union UpdateUserPrivacyPreferencesOutput =
    UnauthorizedError
  | UserError
  | CurrentUser

input UpdateUserPrivacyPreferencesInput {
  show_presence: UserPrivacyPreferenceShowPresenceOptions
}

enum UserPrivacyPreferenceShowPresenceOptions {
  never
  when_online
  where_online
}

union SetUserCoverImageOutput = UserError | UnauthorizedError | CurrentUser

input SetUserCoverImageInput {
  # Image ID to set as the cover image
  imageId: Int

  # Y position offset for adjusting image viewport area
  offsetY: Int

  # Remove the cover image
  remove: Boolean
}

union CreateThemeOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | CustomTheme

input CreateThemeInput {
  title: String!
  description: String!
  colorScheme: CustomThemeColorScheme!
}

union UpdateThemeOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | CustomTheme

input UpdateThemeInput {
  themeId: Int!
  description: String!
  values: UpdateThemeInputThemeValues!
}

input UpdateThemeInputThemeValues {
  global: UpdateThemeInputThemeValuesGlobal!
  editor: UpdateThemeInputThemeValuesEditor!
}

# The global Theme values
input UpdateThemeInputThemeValuesGlobal {
  backgroundRoot: String!
  backgroundDefault: String!
  backgroundHigher: String!
  backgroundHighest: String!
  backgroundOverlay: String!
  foregroundDefault: String!
  foregroundDimmer: String!
  foregroundDimmest: String!
  outlineDimmest: String!
  outlineDimmer: String!
  outlineDefault: String!
  outlineStronger: String!
  outlineStrongest: String!
  accentPrimaryDimmest: String!
  accentPrimaryDimmer: String!
  accentPrimaryDefault: String!
  accentPrimaryStronger: String!
  accentPrimaryStrongest: String!
  accentPositiveDimmest: String!
  accentPositiveDimmer: String!
  accentPositiveDefault: String!
  accentPositiveStronger: String!
  accentPositiveStrongest: String!
  accentNegativeDimmest: String!
  accentNegativeDimmer: String!
  accentNegativeDefault: String!
  accentNegativeStronger: String!
  accentNegativeStrongest: String!
  redDimmest: String!
  redDimmer: String!
  redDefault: String!
  redStronger: String!
  redStrongest: String!
  orangeDimmest: String!
  orangeDimmer: String!
  orangeDefault: String!
  orangeStronger: String!
  orangeStrongest: String!
  yellowDimmest: String!
  yellowDimmer: String!
  yellowDefault: String!
  yellowStronger: String!
  yellowStrongest: String!
  limeDimmest: String!
  limeDimmer: String!
  limeDefault: String!
  limeStronger: String!
  limeStrongest: String!
  greenDimmest: String!
  greenDimmer: String!
  greenDefault: String!
  greenStronger: String!
  greenStrongest: String!
  tealDimmest: String!
  tealDimmer: String!
  tealDefault: String!
  tealStronger: String!
  tealStrongest: String!
  blueDimmest: String!
  blueDimmer: String!
  blueDefault: String!
  blueStronger: String!
  blueStrongest: String!
  blurpleDimmest: String!
  blurpleDimmer: String!
  blurpleDefault: String!
  blurpleStronger: String!
  blurpleStrongest: String!
  purpleDimmest: String!
  purpleDimmer: String!
  purpleDefault: String!
  purpleStronger: String!
  purpleStrongest: String!
  magentaDimmest: String!
  magentaDimmer: String!
  magentaDefault: String!
  magentaStronger: String!
  magentaStrongest: String!
  pinkDimmest: String!
  pinkDimmer: String!
  pinkDefault: String!
  pinkStronger: String!
  pinkStrongest: String!
  greyDimmest: String!
  greyDimmer: String!
  greyDefault: String!
  greyStronger: String!
  greyStrongest: String!
  brownDimmest: String!
  brownDimmer: String!
  brownDefault: String!
  brownStronger: String!
  brownStrongest: String!
  black: String!
  white: String!
}

# The editor Theme values
input UpdateThemeInputThemeValuesEditor {
  syntaxHighlighting: [UpdateThemeInputEditorSyntaxHighlighting!]!
}

# An object which contains CSS styles that are applied to a given set of editor tags
input UpdateThemeInputEditorSyntaxHighlighting {
  tags: [UpdateThemeInputEditorTag]!
  values: JSON!
}

# A selector for a given editor tag
input UpdateThemeInputEditorTag {
  name: String!
  modifiers: [String!]
}

union PublishThemeOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | CustomTheme

input PublishThemeInput {
  themeId: Int!

  # Description for the version of the theme to be published
  description: String
}

union UnpublishThemeOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | CustomTheme

input UnpublishThemeInput {
  themeId: Int!
}

union UnpublishThemeAsModeratorOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | CustomTheme

input UnpublishThemeAsModeratorInput {
  themeId: Int!
  reason: String!
}

union InstallThemeOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | CustomTheme

input InstallThemeInput {
  themeId: Int!
}

union UninstallThemeOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | CustomTheme

input UninstallThemeInput {
  themeId: Int!
}

union DeleteThemeOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | CustomTheme

input DeleteThemeInput {
  themeId: Int!
}

union UpgradeThemeOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | CustomTheme

input UpgradeThemeInput {
  themeId: Int!
}

union SetActiveThemeOutput = UserError | NotFoundError | CustomTheme

# Input for the setActiveTheme mutation. Passing in a null themeId indicates that the custom theme the user has active is cleared in favor of an official theme. Passing in a non-null officialThemeKey sets the official theme to the Replit theme with that key (ignored if themeId is non-null)
input SetActiveThemeInput {
  themeId: Int
  officialThemeKey: OfficialReplitThemeKey
}

enum OfficialReplitThemeKey {
  replitLight
  replitDark
  replitSpooky
}

union ReportCustomThemeOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | BoardReport

union ToggleHiddenCommentOutput =
    ReplComment
  | UserError
  | UnauthorizedError
  | NotFoundError

union ToggleHiddenPostOutput = NotFoundError | UserError | Post

union ImportGithubRepoOutput =
    NotFoundError
  | UserError
  | UnauthorizedError
  | Repl

input ImportGithubRepoInput {
  githubRepoUrl: String!
  teamId: Int
  folderId: String
  activeReplReleaseId: String
  isPrivate: Boolean
  originId: String!
  forkToPersonal: Boolean
}

input GraphQLGitHubApiFile {
  path: String!
  type: GraphQLGitHubApiFileType!
}

enum GraphQLGitHubApiFileType {
  file
  dir
}

union CreateGithubAccessTokenOutput =
    UserError
  | UnauthorizedError
  | ServiceUnavailable
  | CreateGithubAccessTokenResult

type CreateGithubAccessTokenResult {
  # The token for this repository. Tokens last 1hr and are only valid for use with the repository they were created for.
  token: String!
}

input CreateGithubAccessTokenInput {
  # The name of the repository this token will be scoped to.
  repository: String!

  # The owner of the repository to create an access token for.
  owner: String!
}

union WarnUserOutput = UserError | Warning

union RemoveWarnOutput = UserError | Warning

union BanCommunityUserOutput = UserError | BannedBoardUser

union SetReplLayoutStateOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | Repl

input SetReplLayoutStateInput {
  replId: String!
  state: JSON!
}

union SetReplTagsOutput = UnauthorizedError | UserError | NotFoundError | Repl

input SetReplTagsInput {
  replId: String!
  tags: [String!]!
}

union SetReplExamplesOutput =
    UnauthorizedError
  | UserError
  | NotFoundError
  | Repl

input SetReplExamplesInput {
  replId: String!
  exampleReplIds: [String!]!
}

union CreateNewTeamsEduOrganizationOutput =
    UserError
  | UnauthorizedError
  | TeamOrganization

input CreateNewTeamsEduOrganizationInput {
  orgName: String!
}

union SetReplViewSettingsOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | ReplViewSettings

input SetReplViewSettingsInput {
  replId: String!
  defaultView: ReplViewSettingsDefaultView

  # The file used, if the defaultView is repl_file
  replFile: String

  # The image used, if the defaultView is repl_image
  replImage: String
}

enum ReplViewSettingsDefaultView {
  repl_file
  repl_image
}

union CreateTeacherVerificationResponseOutput =
    UserError
  | UnauthorizedError
  | TeacherVerification

input CreateTeacherVerificationResponseInput {
  orgNames: String!
  website: String!
  useCase: String!
  howManyLearners: String!
  referringEmailOrName: String
}

union EscalateBoardUserOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | BoardReport

union ReviewTemplateOutput = UserError | UnauthorizedError | TemplateReview

input ReviewTemplateInput {
  # Template Repl to promote or demote
  replId: String!

  # True to promote, false to demote
  shouldPromote: Boolean!

  # URL slug for template landing page
  landingPageSlug: String
}

union CreateAsanaSupportTaskOutput =
    UserError
  | UnauthorizedError
  | TooManyRequestsError
  | CreateAsanaSupportTaskSuccess

type CreateAsanaSupportTaskSuccess {
  isSuccess: Boolean!
}

input CreateAsanaSupportTaskInput {
  title: String!
  body: CreateAsanaSupportTaskBodyInput!
  board: String!
}

input CreateAsanaSupportTaskBodyInput {
  message: String!
  pageUrl: String!
  loomUrl: String
  userAgent: String!
  currentUser: CreateAsanaSupportTaskUser!
}

input CreateAsanaSupportTaskUser {
  userId: Int!
  username: String!
  email: String!
  isHacker: Boolean!
  daysSinceSignup: Int!
  isExplorer: Boolean!
  isTeacher: Boolean!
}

union CreateAsanaFeedbackTaskOutput =
    UserError
  | UnauthorizedError
  | TooManyRequestsError
  | CreateAsanaFeedbackTaskSuccess

type CreateAsanaFeedbackTaskSuccess {
  isSuccess: Boolean!
}

input CreateAsanaFeedbackTaskInput {
  title: String!
  body: CreateAsanaFeedbackTaskBodyInput!
  project: String!
  membership: CreateAsanaFeedbackTaskMembership!
}

input CreateAsanaFeedbackTaskBodyInput {
  description: String!
  pageUrl: String!
  loomUrl: String
  userAgent: String!
  replitVersion: String
  currentUser: CreateAsanaFeedbackTaskUser!
}

input CreateAsanaFeedbackTaskUser {
  userId: Int!
  username: String!
  email: String!
  isHacker: Boolean!
  daysSinceSignup: Int!
  isExplorer: Boolean!
  isTeacher: Boolean!
}

input CreateAsanaFeedbackTaskMembership {
  project: String!
  section: String!
}

union UpdatePrivatePowerUpOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | UserPowerUpDescriptionType

union UpdatePrivatePowerUp2Output =
    UserError
  | UnauthorizedError
  | NotFoundError
  | CurrentUser

union UnbanCommunityUserOutput = UserError | User

input UnbanCommunityUserInput {
  username: String!
}

union ChangeLanguagetoNixOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | Repl

union ModeratorUnpublishOutput = NotFoundError | UnauthorizedError | Repl

input ModeratorUnpublishInput {
  replId: String!
  reason: String!
}

union CreateUserCourseOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | UserCourseResult

type UserCourseResult {
  userCourse: UserCourse!
}

input CreateUserCourseInput {
  # The course to start.
  courseSlug: String!
}

union CreateUserCourseLessonOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | UserCourseLessonResult

type UserCourseLessonResult {
  userCourseLesson: UserCourseLesson!
}

input CreateUserCourseLessonInput {
  # The UserCourse associated with the lesson. This id is an integer.
  userCourseId: Int!

  # The lesson being created.
  lessonSlug: String!

  # The locale for which we want to create the lesson. If not provided, defaults to "en-US".
  locale: String = "en-US"

  # Deprecated. The server handles Repl forking now.
  replId: String
}

union UpdateUserCourseLessonOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | UpdatedUserCourseLesson

type UpdatedUserCourseLesson {
  userCourseLesson: UserCourseLesson!
}

input CompleteUserCourseLessonInput {
  # The numeric ID for the UserCourseLesson to update.
  userLessonId: Int!
}

union RestartUserCourseLessonOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | UserCourseLessonResult

input RestartUserCourseLessonInput {
  # The ID for the lesson to be restarted.
  userLessonId: Int!

  # The locale for which we want the user to restart their lesson. If not provided, defaults to "en-US"
  locale: String = "en-US"
}

union SetTemplateCategoryReplOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | TemplateCategoryReplResult

type TemplateCategoryReplResult {
  templateCategoryRepl: TemplateCategoryRepls!
}

# Assign a template category to a template repl.
type TemplateCategoryRepls {
  id: Int!
  replId: String!
  templateCategoryId: Int!
  timeCreated: Date!
}

input SetTemplateCategoryReplInput {
  # The associated repl id.
  replId: String!

  # The target template category id.
  templateCategoryId: Int!
}

union UnsetTemplateCategoryReplOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | TemplateCategoryReplResult

input UnsetTemplateCategoryReplInput {
  # The associated repl id.
  replId: String!

  # The target template category id.
  templateCategoryId: Int!
}

union CreateAsanaFeedbackTaskOutputReturnGID =
    UserError
  | UnauthorizedError
  | TooManyRequestsError
  | CreateAsanaFeedbackTaskSuccessReturnGID

type CreateAsanaFeedbackTaskSuccessReturnGID {
  isSuccess: Boolean!
  asanaGID: String!
}

input CreateAsanaFeedbackTaskInputReturnGID {
  title: String!
  body: CreateAsanaFeedbackTaskBodyInputReturnGID!
  project: String!
  membership: CreateAsanaFeedbackTaskMembershipReturnGID!
}

input CreateAsanaFeedbackTaskBodyInputReturnGID {
  description: String!
  pageUrl: String!
  loomUrl: String
  userAgent: String!
  replitVersion: String
  currentUser: CreateAsanaFeedbackTaskUserReturnGID!
}

input CreateAsanaFeedbackTaskUserReturnGID {
  userId: Int!
  username: String!
  email: String!
  isHacker: Boolean!
  daysSinceSignup: Int!
  isExplorer: Boolean!
  isTeacher: Boolean!
}

input CreateAsanaFeedbackTaskMembershipReturnGID {
  project: String!
  section: String!
}

union ModeratorNotificationOutput =
    MentionedInPostNotification
  | MentionedInCommentNotification
  | RepliedToCommentNotification
  | RepliedToPostNotification
  | AnswerAcceptedNotification
  | MultiplayerJoinedEmailNotification
  | MultiplayerJoinedLinkNotification
  | MultiplayerInvitedNotification
  | MultiplayerOverlimitNotification
  | WarningNotification
  | TeamInviteNotification
  | TeamOrganizationInviteNotification
  | BasicNotification
  | TeamTemplateSubmittedNotification
  | TeamTemplateReviewedStatusNotification
  | AnnotationNotification
  | EditRequestCreatedNotification
  | EditRequestAcceptedNotification
  | ReplCommentCreatedNotification
  | ReplCommentReplyCreatedNotification
  | ReplCommentMentionNotification
  | ThreadNotification
  | NewFollowerNotification
  | BountyApplicationReviewedNotification
  | BountyNewApplicationNotification
  | BountyNewSubmissionNotification
  | BountySubmissionReviewedNotification
  | BountyChatMessageNotification
  | TipReceivedNotification
  | EgressLimitNotification
  | NotFoundError
  | UnauthorizedError

input ModeratorNotificationInput {
  username: String!
  text: String!
  url: String!
}

union CreateBountyOutput =
    UserError
  | UnauthorizedError
  | TooManyRequestsError
  | Bounty

input CreateBountyInput {
  title: String!
  description: String!
  cycles: Int!
  deadline: DateTime!
  contactMethod: BountyContactMethod!
  contactInfo: String!
  isUnlisted: Boolean
}

union EditBountyOutput = UserError | UnauthorizedError | NotFoundError | Bounty

input EditBountyInput {
  bountyId: Int!
  title: String
  description: String
  cycles: Int
  deadline: DateTime
  contactInfo: String
}

union CancelBountyOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | Bounty

input CancelBountyInput {
  id: Int!
}

union CreateBountyApplicationOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | TooManyRequestsError
  | BountyApplication

input CreateBountyApplicationInput {
  bountyId: Int!
  content: String!
  contactInfo: String!
  hcaptchaResponse: String
  hcaptchaSiteKey: String
}

union CreateBountySubmissionOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | BountySubmission

input CreateBountySubmissionInput {
  bountyId: Int!

  # The text content of the submission
  content: String!

  # Repls that should be part of this submission and shared with the Bounty poster
  replIds: [String!]
}

union CreateBountySubmissionReviewOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | BountySubmissionReview

input CreateBountySubmissionReviewInput {
  bountySubmissionId: Int!
  isAccepted: Boolean!
  content: String
}

union ReviewBountyApplicationOutput =
    NotFoundError
  | UnauthorizedError
  | UserError
  | BountyApplication

input ReviewBountyApplicationInput {
  bountyApplicationId: Int!
  status: ReviewBountyApplicationStatus!
}

enum ReviewBountyApplicationStatus {
  accepted
  rejected
  notReviewed
}

union ModerateBountyApplicationOutput =
    NotFoundError
  | UnauthorizedError
  | UserError
  | BountyApplication

input ModerateBountyApplicationInput {
  bountyApplicationId: Int!
  action: ModerateBountyApplicationAction!
  reason: String
  notifyApplicant: Boolean
}

enum ModerateBountyApplicationAction {
  delete
  approve
}

union SetBountyUnlistedOutput = UserError | UnauthorizedError | Bounty

union ForceSolverToAbandonBountyAsStaffOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | Bounty

input ForceSolverToAbandonBountyAsStaffInput {
  bountyId: Int!
  reason: String!
}

union CancelBountyAsStaffOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | Bounty

input CancelBountyAsStaffInput {
  bountyId: Int!
  reason: String!
}

union AbandonBountyOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | Bounty

input AbandonBountyInput {
  bountyId: Int!
}

union RemoveBountyApplicationAsModeratorOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | BountyApplication

input RemoveBountyApplicationAsModeratorInput {
  bountyApplicationId: Int!
  reason: String!
}

union RemoveBountyApplicationAsApplicantOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | BountyApplication

input RemoveBountyApplicationAsApplicantInput {
  bountyApplicationId: Int!
}

union ReviewBountyHunter =
    UserError
  | UnauthorizedError
  | NotFoundError
  | BountyHunterReview

input ReviewBountyHunterInput {
  bountyId: Int!
  userToReviewId: Int!
  communicationRating: Int!
  qualityRating: Int!
  timelinessRating: Int!
  reviewText: String
}

union RemoveBountyHunterReviewAsStaffOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | BountyHunterReview

input RemoveBountyHunterReviewAsStaffInput {
  bountyHunterReviewId: Int!
  reason: String!
}

union SendBountyChatOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | TooManyRequestsError
  | ServiceUnavailable
  | BountyChatMessage

input SendBountyChatInput {
  bountyApplicationId: Int!
  message: String!
}

union MarkBountyChatReadOutput =
    NotFoundError
  | UnauthorizedError
  | BountyChatMessage

input MarkBountyChatReadInput {
  bountyApplicationId: Int!
}

union HireBountyHunterServiceOutput =
    UserError
  | TooManyRequestsError
  | UnauthorizedError
  | NotFoundError
  | ServiceUnavailable
  | HireBountyHunterServiceSuccess

type HireBountyHunterServiceSuccess {
  hireRequestId: String!
  bountyHunterService: BountyHunterService!
}

input HireBountyHunterServiceInput {
  bountyHunterServiceId: Int!
  email: String!
}

union SetGpuOutput = UserError | UnauthorizedError | Repl

union SetStorageCapacityOutput =
    NotFoundError
  | UserError
  | UnauthorizedError
  | Repl

input SetStorageCapacityInput {
  # The ID of the Repl to update
  replId: ID!

  # The desired storage capacity for the targeted Repl
  storageCapacity: ReplStorageCapacity!
}

union SetUserStorageQuotaOutput =
    UnauthorizedError
  | ServiceUnavailable
  | SetUserStorageQuotaSuccess

type SetUserStorageQuotaSuccess {
  # The new quota in bytes.
  quota: String!
}

union createCyclesStripeCheckoutSession =
    UserError
  | UnauthorizedError
  | CreateCyclesStripeCheckoutSessionResult

type CreateCyclesStripeCheckoutSessionResult {
  sessionUrl: String!
}

input CreateCyclesStripeCheckoutSessionInput {
  quantity: Int!
  purchaseType: CyclesPurchaseType!
  redirectDestination: CyclesRedirectDestinationType

  # Title of a Repl if redirectDestination is to the Workspace
  redirectReplTitle: String
  redirectTipSurface: CyclesCheckoutRedirectTipSurface
}

# The type of purchase (one-time payment or subscription)
enum CyclesPurchaseType {
  oneTime
  recurringChargeNow
    @deprecated(
      reason: "Cycles subscriptions are deprecated. Please set up Auto-Refill instead: replit.com/cycles/set-up-auto-refill"
    )
}

# Destination in Replit app to redirect the user to after successful checkout
enum CyclesRedirectDestinationType {
  newReplModal
  cyclesPage
  workspace
  profile
  bounties
  tipSurface
  account
}

# Tip surface to redirect to, if redirectDestination is tipSurface
input CyclesCheckoutRedirectTipSurface {
  # Username of the tip surface owner
  username: String!

  # Slug of the tip surface
  slug: String!

  # Type of tip surface
  surfaceType: CyclesCheckoutTippableSurfaceType!

  # Amount of Cycles the user intended to tip
  desiredAmount: Int!
}

# Type of tip surface
enum CyclesCheckoutTippableSurfaceType {
  repl
  theme
}

# Power Up to purchase after a successful checkout
enum CyclesCheckoutPurchasePowerUpType {
  ghostwriter
}

union BulkModerateOutput =
    UserError
  | UnauthorizedError
  | TooManyRequestsError
  | BulkModerateResult

type BulkModerateResult {
  # The success message
  message: String!

  # The moderation action taken
  action: String!

  # The reason for moderating the repls, comments, users, etc.
  reason: String!
}

input BulkModerateInputArg {
  # The ids of the comments for comment moderation actions
  commentIds: [Int!]

  # The ids of the repls, comments, users as string
  replIds: [String!]
  userIds: [Int!]

  # The ids of the posts for post moderation actions
  postIds: [Int!]
  action: BulkModerateAction!

  # The reason for moderating the repls, comments, users, etc.
  reason: String!
}

enum BulkModerateAction {
  banCommunityUser
  banUser
  deleteRepl
  hideComment
  hidePost
  poisonRepl
  reportRepl
  reportReplComment
}

union UpdateGhostwriterPowerUpOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | CurrentUser

input UpdateGhostwriterPowerUpInput {
  active: Boolean!
}

union ReplBootStatusStopRepl =
    UnauthorizedError
  | UserError
  | ReplBootStatusStopReplSuccess

# Successfully stopped repl
type ReplBootStatusStopReplSuccess {
  message: String!
}

union SendTipOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | SendTipResult

type SendTipResult {
  repl: Repl
  theme: CustomTheme
  currentUser: CurrentUser!
}

input SendTipInput {
  replId: String
  themeId: Int
  amount: Int!
}

union CreateNeonDatabaseOutput =
    UserError
  | UnauthorizedError
  | CreateNeonDatabaseResult

type CreateNeonDatabaseResult {
  projectId: String!
  databaseId: Int!
  databaseName: String!
  connectionString: String!
  isFrozen: Boolean!
}

input CreateNeonDatabaseInput {
  replId: String!
}

union DeleteNeonDatabaseOutput =
    UserError
  | UnauthorizedError
  | DeleteNeonDatabaseResult

type DeleteNeonDatabaseResult {
  success: Boolean!
}

input DeleteNeonDatabaseInput {
  replId: String!
  databaseId: Int!
}

union FreezeNeonDatabaseOutput =
    UserError
  | UnauthorizedError
  | FreezeNeonDatabaseResult

type FreezeNeonDatabaseResult {
  success: Boolean!
}

input FreezeNeonDatabaseInput {
  replId: String!
  neonProjectId: String!
}

union UnfreezeNeonDatabaseOutput =
    UserError
  | UnauthorizedError
  | UnfreezeNeonDatabaseResult

type UnfreezeNeonDatabaseResult {
  success: Boolean!
}

input UnfreezeNeonDatabaseInput {
  replId: String!
  neonProjectId: String!
}

union AsanaSupportRequestOutput =
    UserError
  | UnauthorizedError
  | TooManyRequestsError
  | AsanaSupportRequestSuccess

type AsanaSupportRequestSuccess {
  success: Boolean!
  asanaTaskGID: String!
  attachments: [String]
  tagsAttached: [String]
}

input AsanaSupportRequestInput {
  title: String!
  body: String!
  type: String!
  attachments: [Int!]
  clientInformation: AsanaSupportRequestClientSideInput
  projects: [String!]
}

input AsanaSupportRequestClientSideInput {
  pageUrl: String
  browser: String
  device: String
}

union FailHostingBuildOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | FailHostingBuildResult

type FailHostingBuildResult {
  deployment: HostingDeployment!
  build: HostingBuild!
  activityLog: HostingActivityLog!
}

input FailHostingBuildInput {
  buildId: String!
  targetDeploymentId: String!
}

union BoostRepl2Output =
    PaymentError
  | UserError
  | UnauthorizedError
  | BoostRepl2Result

type BoostRepl2Result {
  repl: Repl!
  currentUser: CurrentUser!
}

input BoostRepl2Input {
  replId: String!

  # The SKU of the Boost to use or off to turn off Boost.
  setting: BoostSettingEnum!

  # Expected Cycles cost for the Boost. Will prevent the mutation from Boosting if the actual Cycles cost is greater than expected.
  expectedCyclesCost: Int
}

enum BoostSettingEnum {
  off
  boost_2cpu_2ram
  boost_4cpu_4ram
  boost_8cpu_8ram
  boost_16cpu_16ram
}

union ImageScanType = UserError | UnauthorizedError | ImageScan

union RegisterPushDeviceSessionOutput =
    UserError
  | UnauthorizedError
  | RegisterPushDeviceSessionResult

type RegisterPushDeviceSessionResult {
  deviceId: String
}

input RegisterPushDeviceSessionInput {
  deviceId: String!
  token: String!
  tokenType: PushNotificationTokenType!
}

# The token type for push notifications
enum PushNotificationTokenType {
  expo
  web
}

union UnregisterPushDeviceSessionOutput =
    UserError
  | NotFoundError
  | UnregisterPushDeviceSessionResult

type UnregisterPushDeviceSessionResult {
  success: Boolean!
}

input UnregisterPushDeviceSessionInput {
  deviceId: String!
}

union AcceptInvoiceOutput =
    UnauthorizedError
  | UserError
  | NotFoundError
  | Invoice

union DenyInvoiceOutput =
    UnauthorizedError
  | UserError
  | NotFoundError
  | Invoice

union InstallExtensionOutput =
    UnauthorizedError
  | UserError
  | ExtensionInstallation

union AddReplIdentityAllowedRepl = NotFoundError | UnauthorizedError | Repl

input AddReplIdentityAllowedReplInput {
  replId: String!
}

union DeleteReplIdentityAllowedRepl = NotFoundError | UnauthorizedError | Repl

input DeleteReplIdentityAllowedReplInput {
  replId: String!
}

union CreateInvoiceOutput = UnauthorizedError | UserError | Invoice

union ConfirmInvoiceOutput =
    UnauthorizedError
  | UserError
  | NotFoundError
  | Invoice

union CancelInvoiceOutput =
    UnauthorizedError
  | UserError
  | NotFoundError
  | Invoice

union UninstallExtensionOutput =
    NotFoundError
  | UserError
  | ExtensionInstallation

union DeployHostingBuild2Output =
    UserError
  | NotFoundError
  | UnauthorizedError
  | DeployHostingBuild2Result

type DeployHostingBuild2Result {
  build: HostingBuild!
  targetDeployment: HostingDeployment!
}

input DeployHostingBuild2Input {
  replId: String!

  # Target deployment for build. If null build is treated as first build and new deployment will be created if none already exist.
  targetDeploymentId: String

  # The subdomain to use with replit.app. If none is provided, we use slug-username.
  subdomain: String
  commands: DeployHostingBuild2Commands!
  envVars: [DeployHostingBuild2EnvVar!]
  provider: HostingBuildProvider
  appType: DeployHostingBuildAppType
}

input DeployHostingBuild2Commands {
  build: String
  run: String!
}

input DeployHostingBuild2EnvVar {
  name: String!
  value: String!
}

enum DeployHostingBuildAppType {
  cloud_run
  server
  static
  worker
}

union SendPushToStaff = UnauthorizedError | SendPushToStaffResult

# If the notification was sent successfully
type SendPushToStaffResult {
  success: Boolean!
}

input SendPushToStaffInput {
  messageTitle: String!
  messageBody: String!
  url: String
}

union DeleteThreadMessageOutput = UserError | AnnotationAnchor

union ChangeSubscriptionOutput =
    PaymentError
  | UserError
  | UnauthorizedError
  | ChangeSubscriptionResult

type ChangeSubscriptionResult {
  currentUser: CurrentUser!
  paymentIntentStatus: UpdateSubscriptionResultPaymentIntentStatus
  hostedInvoiceUrl: String
}

enum UpdateSubscriptionResultPaymentIntentStatus {
  succeeded
  requires_payment_method
  requires_action
}

input ChangeSubscriptionInput {
  # The plan prefix of the subscription type to change the users current subscription to
  newPlanPrefix: SelectableSubscriptionPrefixTypesEnum!

  # The plan period of the subscription type to change the users current subscription to
  newPlanPeriod: SelectableSubscriptionPeriodTypesEnum!
}

union AdminRemoveUserImageOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | User

union CreateSetupIntentOutput =
    UserError
  | UnauthorizedError
  | CreateSetupIntentResult

type CreateSetupIntentResult {
  clientSecret: String!
}

union UpdateCyclesAutoRefillConfigurationOutput =
    UserError
  | UnauthorizedError
  | CurrentUser

input UpdateCyclesAutoRefillConfigurationInput {
  # Whether Auto-Refill is enabled
  enabled: Boolean!

  # USD cents maximum purchase total per calendar month. If unspecified there is no maximum.
  monthlyBudget: Int
}

union AppStoreCustomerOutput =
    UserError
  | UnauthorizedError
  | AppStoreCustomerResult

type AppStoreCustomerResult {
  appAccountToken: String!
}

union PlayStoreCustomerOutput =
    UserError
  | UnauthorizedError
  | PlayStoreCustomerResult

type PlayStoreCustomerResult {
  appAccountToken: String!
}

union CreateReplitOneTimeCheckoutSessionOutput =
    UserError
  | UnauthorizedError
  | PaymentError
  | CreateReplitOneTimeCheckoutSessionResult

type CreateReplitOneTimeCheckoutSessionResult {
  clientSecret: String!
  checkoutSession: ReplitCheckoutSession!

  # The current user, can be used to refetch Auto-Refill configuration or payment method to update the client cache
  currentUser: CurrentUser!
}

input CreateReplitOneTimeCheckoutSessionInput {
  # The number of Cycles to purchase
  cyclesQuantity: Int!

  # The PowerUp to apply after the Cycles purchase
  postPurchasePowerUp: PostPurchasePowerUp

  # If specified, update the user's Auto-Refill configuration
  cyclesAutoRefillConfiguration: UpdateCyclesAutoRefillConfigurationInput
}

input PostPurchasePowerUp {
  replPowerUp: PostPurchaseReplPowerUp!
}

input PostPurchaseReplPowerUp {
  replId: String!
  type: PostPurchaseReplPowerUpOrderTypeEnumType!
  sku: PostPurchaseReplPowerUpSkuEnumType!
}

enum PostPurchaseReplPowerUpOrderTypeEnumType {
  boost
  hosting_tier
}

enum PostPurchaseReplPowerUpSkuEnumType {
  boost_2cpu_2ram
  boost_4cpu_4ram
  boost_8cpu_8ram
  boost_16cpu_16ram
  hosting_tier_e2_micro
  hosting_tier_e2_small
  hosting_tier_e2_medium
  hosting_tier_n1_custom_1_4
  hosting_tier_e2_standard_2
  hosting_tier_e2_standard_4
}

union CreateReplitPlanCheckoutSessionOutput =
    UserError
  | UnauthorizedError
  | CreateReplitPlanCheckoutSessionResult

type CreateReplitPlanCheckoutSessionResult {
  clientSecret: String!
  checkoutSession: ReplitCheckoutSession!
  currentUser: CurrentUser!
}

input CreateReplitPlanCheckoutSessionInput {
  # The plan prefix of the subscription type to change the users current subscription to
  planPrefix: SelectableSubscriptionPrefixTypesEnum!

  # The plan period of the subscription type to change the users current subscription to
  planPeriod: SelectableSubscriptionPeriodTypesEnum!
}

union AdminRemoveReplIconOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | Repl

union CreateGithubRepoOutput =
    UserError
  | UnauthorizedError
  | CreateGithubRepoResult

type CreateGithubRepoResult {
  remoteUrl: String!
}

input CreateGithubRepoInput {
  name: String!
  description: String
  homepage: String
  isPrivate: Boolean!
  ownerType: GithubRepoOwnerType!
}

# The owner type of a GitHub repository
enum GithubRepoOwnerType {
  user
  organization
}

union EgressLimitAddOnOutput =
    PaymentError
  | UserError
  | UnauthorizedError
  | EgressLimitAddOnResult

type EgressLimitAddOnResult {
  currentUser: CurrentUser!
}

input EgressLimitAddOnInput {
  # The SKU of the requested add-on.
  sku: EgressAddOnSku!
}

union SetHostingTierOutput =
    PaymentError
  | UserError
  | UnauthorizedError
  | SetHostingTierResult

type SetHostingTierResult {
  repl: Repl!
  currentUser: CurrentUser!
}

input SetHostingTierInput {
  replId: String!

  # The desired SKU of the hosting tier or whether to suspend it.
  sku: HostingTierPowerUpSku!
}

union DeployExtensionOutput = UserError | TooManyRequestsError | Extension

union SendDeploymentLifecycleCommandOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | SendDeploymentLifecycleCommandResult

type SendDeploymentLifecycleCommandResult {
  repl: Repl!
  currentUser: CurrentUser!
}

input SendDeploymentLifecycleCommandInput {
  replId: String!

  # The desired lifecycle command to be sent.
  command: SendDeploymentLifecycleCommandType!
  buildId: String
}

enum SendDeploymentLifecycleCommandType {
  resume
  suspend
  destroy
}

union SetUserKeybindingsOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | Keybindings

input SetUserKeybindingsInput {
  environment: KeybindingsEnvironmentEnum!
  platform: KeybindingsPlatformEnum!
  keybindings: JSON!
}

union CreateExtensionOutput =
    UnauthorizedError
  | TooManyRequestsError
  | UserError
  | Extension

# The top level entry point for subscribing to graph events
type RootSubscriptionType {
  # A subscriptions test
  testSubscription: SubscriptionTestObject

  # Updates to annotations in a given repl. Returns the updated annotation
  annotationUpdatesByRepl(replId: String!): AnnotationAnchor

  # A subscription to events regarding changes to the online status of repls in a team
  teamReplConnections(teamId: Int!): TeamConnectionEvent!

  # The subscription used to register a connection to a repl.
  replConnection(replId: String!): Boolean

  # Streams the notification count to current user
  notificationCount: Int!
  threadPreview(threadId: String!): ThreadPreview

  # Updates to the current user's write permissions for a given repl.
  currentUserCanWrite(replId: String!): Boolean!

  # Returns live repl status events.
  replBootStatusUpdates(
    input: ReplBootStatusUpdatesInput
  ): ReplBootStatusUpdateEvent!
  latestBountyChatMessage(
    input: LatestBountyChatMessageInput!
  ): BountyChatMessage

  # Returns repl hosting deploy action updates.
  hostingBuildDeployActionUpdates(
    input: HostingBuildDeployActionUpdatesInput!
  ): HostingBuildDeployActionUpdateEvent!
}

type SubscriptionTestObject {
  timestamp: String
  username: String
}

# Events used for sending information on team connections
union TeamConnectionEvent =
    RemoveReplConnectionsEvent
  | UpdateReplConnectionsEvent

# The event called when there are no longer any connections to a Repl.
type RemoveReplConnectionsEvent {
  replId: String!

  # The time when the data was returned
  epoch: DateTime!
}

# The event sent when the list of connected users for a Repl changes or is created.
type UpdateReplConnectionsEvent {
  # The Repl which users are connected to
  repl: Repl!

  # The users that are connected to the Repl
  users: [User!]!

  # The time when the data was returned
  epoch: DateTime!
}

type ThreadPreview {
  userId: Int!
  messageId: String!
  message: String
}

# A repl status update event.
type ReplBootStatusUpdateEvent {
  repl: Repl!

  # Type of repl boot event (stopped, starting, started, or stopping).
  status: ReplBootStatusValue!
  timestamp: DateTime!
}

input ReplBootStatusUpdatesInput {
  # Optional list of repl IDs to filter/fetch by.
  replIds: [String]
}

input LatestBountyChatMessageInput {
  bountyApplicationId: Int!
}

input HostingBuildDeployActionUpdatesInput {
  buildId: String!
}
